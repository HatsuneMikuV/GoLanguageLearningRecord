<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>x509 - The Go Programming Language</title>

<link type="text/css" rel="stylesheet" href="/lib/godoc/style.css">

<link rel="search" type="application/opensearchdescription+xml" title="godoc" href="/opensearch.xml" />

<link rel="stylesheet" href="/lib/godoc/jquery.treeview.css">
<script>window.initFuncs = [];</script>
<script src="/lib/godoc/jquery.js" defer></script>
<script src="/lib/godoc/jquery.treeview.js" defer></script>
<script src="/lib/godoc/jquery.treeview.edit.js" defer></script>


<script src="/lib/godoc/playground.js" defer></script>

<script>var goVersion = "go1.10.1";</script>
<script src="/lib/godoc/godocs.js" defer></script>
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(["_setAccount", "UA-11222381-2"]);
_gaq.push(["b._setAccount", "UA-49880327-6"]);
window.trackPageview = function() {
  _gaq.push(["_trackPageview", location.pathname+location.hash]);
  _gaq.push(["b._trackPageview", location.pathname+location.hash]);
};
window.trackPageview();
window.trackEvent = function(category, action, opt_label, opt_value, opt_noninteraction) {
  _gaq.push(["_trackEvent", category, action, opt_label, opt_value, opt_noninteraction]);
  _gaq.push(["b._trackEvent", category, action, opt_label, opt_value, opt_noninteraction]);
};
</script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="/">The Go Programming Language</a></div>
<div class="top-heading" id="heading-narrow"><a href="/">Go</a></div>
<a href="#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="/search">
<div id="menu">
<a href="/doc/">Documents</a>
<a href="/pkg/">Packages</a>
<a href="/project/">The Project</a>
<a href="/help/">Help</a>


<a id="playgroundButton" href="http://play.golang.org/" title="Show Go Playground">Play</a>

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>


<div id="playground" class="play">
	<div class="input"><textarea class="code" spellcheck="false">package main

import "fmt"

func main() {
	fmt.Println("Hello, 世界")
}</textarea></div>
	<div class="output"></div>
	<div class="buttons">
		<a class="run" title="Run this code [shift-enter]">Run</a>
		<a class="fmt" title="Format this code">Format</a>
		
	</div>
</div>


<div id="page" class="wide">
<div class="container">


  <h1>
    Package x509
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script type='text/javascript'>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "crypto/x509"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
				<dd><a href="#pkg-subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
Package x509 parses X.509-encoded keys and certificates.
</p>
<p>
On UNIX systems the environment variables SSL_CERT_FILE and SSL_CERT_DIR
can be used to override the system default locations for the SSL certificate
file and SSL certificate files directory, respectively.
</p>

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
			
				<dd><a href="#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="#CreateCertificate">func CreateCertificate(rand io.Reader, template, parent *Certificate, pub, priv interface{}) (cert []byte, err error)</a></dd>
			
				
				<dd><a href="#CreateCertificateRequest">func CreateCertificateRequest(rand io.Reader, template *CertificateRequest, priv interface{}) (csr []byte, err error)</a></dd>
			
				
				<dd><a href="#DecryptPEMBlock">func DecryptPEMBlock(b *pem.Block, password []byte) ([]byte, error)</a></dd>
			
				
				<dd><a href="#EncryptPEMBlock">func EncryptPEMBlock(rand io.Reader, blockType string, data, password []byte, alg PEMCipher) (*pem.Block, error)</a></dd>
			
				
				<dd><a href="#IsEncryptedPEMBlock">func IsEncryptedPEMBlock(b *pem.Block) bool</a></dd>
			
				
				<dd><a href="#MarshalECPrivateKey">func MarshalECPrivateKey(key *ecdsa.PrivateKey) ([]byte, error)</a></dd>
			
				
				<dd><a href="#MarshalPKCS1PrivateKey">func MarshalPKCS1PrivateKey(key *rsa.PrivateKey) []byte</a></dd>
			
				
				<dd><a href="#MarshalPKCS1PublicKey">func MarshalPKCS1PublicKey(key *rsa.PublicKey) []byte</a></dd>
			
				
				<dd><a href="#MarshalPKCS8PrivateKey">func MarshalPKCS8PrivateKey(key interface{}) ([]byte, error)</a></dd>
			
				
				<dd><a href="#MarshalPKIXPublicKey">func MarshalPKIXPublicKey(pub interface{}) ([]byte, error)</a></dd>
			
				
				<dd><a href="#ParseCRL">func ParseCRL(crlBytes []byte) (*pkix.CertificateList, error)</a></dd>
			
				
				<dd><a href="#ParseCertificates">func ParseCertificates(asn1Data []byte) ([]*Certificate, error)</a></dd>
			
				
				<dd><a href="#ParseDERCRL">func ParseDERCRL(derBytes []byte) (*pkix.CertificateList, error)</a></dd>
			
				
				<dd><a href="#ParseECPrivateKey">func ParseECPrivateKey(der []byte) (*ecdsa.PrivateKey, error)</a></dd>
			
				
				<dd><a href="#ParsePKCS1PrivateKey">func ParsePKCS1PrivateKey(der []byte) (*rsa.PrivateKey, error)</a></dd>
			
				
				<dd><a href="#ParsePKCS1PublicKey">func ParsePKCS1PublicKey(der []byte) (*rsa.PublicKey, error)</a></dd>
			
				
				<dd><a href="#ParsePKCS8PrivateKey">func ParsePKCS8PrivateKey(der []byte) (key interface{}, err error)</a></dd>
			
				
				<dd><a href="#ParsePKIXPublicKey">func ParsePKIXPublicKey(derBytes []byte) (pub interface{}, err error)</a></dd>
			
			
				
				<dd><a href="#CertPool">type CertPool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewCertPool">func NewCertPool() *CertPool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SystemCertPool">func SystemCertPool() (*CertPool, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CertPool.AddCert">func (s *CertPool) AddCert(cert *Certificate)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CertPool.AppendCertsFromPEM">func (s *CertPool) AppendCertsFromPEM(pemCerts []byte) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CertPool.Subjects">func (s *CertPool) Subjects() [][]byte</a></dd>
				
			
				
				<dd><a href="#Certificate">type Certificate</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ParseCertificate">func ParseCertificate(asn1Data []byte) (*Certificate, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Certificate.CheckCRLSignature">func (c *Certificate) CheckCRLSignature(crl *pkix.CertificateList) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Certificate.CheckSignature">func (c *Certificate) CheckSignature(algo SignatureAlgorithm, signed, signature []byte) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Certificate.CheckSignatureFrom">func (c *Certificate) CheckSignatureFrom(parent *Certificate) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Certificate.CreateCRL">func (c *Certificate) CreateCRL(rand io.Reader, priv interface{}, revokedCerts []pkix.RevokedCertificate, now, expiry time.Time) (crlBytes []byte, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Certificate.Equal">func (c *Certificate) Equal(other *Certificate) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Certificate.Verify">func (c *Certificate) Verify(opts VerifyOptions) (chains [][]*Certificate, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Certificate.VerifyHostname">func (c *Certificate) VerifyHostname(h string) error</a></dd>
				
			
				
				<dd><a href="#CertificateInvalidError">type CertificateInvalidError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CertificateInvalidError.Error">func (e CertificateInvalidError) Error() string</a></dd>
				
			
				
				<dd><a href="#CertificateRequest">type CertificateRequest</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ParseCertificateRequest">func ParseCertificateRequest(asn1Data []byte) (*CertificateRequest, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CertificateRequest.CheckSignature">func (c *CertificateRequest) CheckSignature() error</a></dd>
				
			
				
				<dd><a href="#ConstraintViolationError">type ConstraintViolationError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ConstraintViolationError.Error">func (ConstraintViolationError) Error() string</a></dd>
				
			
				
				<dd><a href="#ExtKeyUsage">type ExtKeyUsage</a></dd>
				
				
			
				
				<dd><a href="#HostnameError">type HostnameError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#HostnameError.Error">func (h HostnameError) Error() string</a></dd>
				
			
				
				<dd><a href="#InsecureAlgorithmError">type InsecureAlgorithmError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#InsecureAlgorithmError.Error">func (e InsecureAlgorithmError) Error() string</a></dd>
				
			
				
				<dd><a href="#InvalidReason">type InvalidReason</a></dd>
				
				
			
				
				<dd><a href="#KeyUsage">type KeyUsage</a></dd>
				
				
			
				
				<dd><a href="#PEMCipher">type PEMCipher</a></dd>
				
				
			
				
				<dd><a href="#PublicKeyAlgorithm">type PublicKeyAlgorithm</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PublicKeyAlgorithm.String">func (algo PublicKeyAlgorithm) String() string</a></dd>
				
			
				
				<dd><a href="#SignatureAlgorithm">type SignatureAlgorithm</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#SignatureAlgorithm.String">func (algo SignatureAlgorithm) String() string</a></dd>
				
			
				
				<dd><a href="#SystemRootsError">type SystemRootsError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#SystemRootsError.Error">func (se SystemRootsError) Error() string</a></dd>
				
			
				
				<dd><a href="#UnhandledCriticalExtension">type UnhandledCriticalExtension</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#UnhandledCriticalExtension.Error">func (h UnhandledCriticalExtension) Error() string</a></dd>
				
			
				
				<dd><a href="#UnknownAuthorityError">type UnknownAuthorityError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#UnknownAuthorityError.Error">func (e UnknownAuthorityError) Error() string</a></dd>
				
			
				
				<dd><a href="#VerifyOptions">type VerifyOptions</a></dd>
				
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<dl>
			
			<dd><a class="exampleLink" href="#example_Certificate_Verify">Certificate.Verify</a></dd>
			
			<dd><a class="exampleLink" href="#example_ParsePKIXPublicKey">ParsePKIXPublicKey</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="/src/crypto/x509/cert_pool.go">cert_pool.go</a>
			
				<a href="/src/crypto/x509/pem_decrypt.go">pem_decrypt.go</a>
			
				<a href="/src/crypto/x509/pkcs1.go">pkcs1.go</a>
			
				<a href="/src/crypto/x509/pkcs8.go">pkcs8.go</a>
			
				<a href="/src/crypto/x509/root.go">root.go</a>
			
				<a href="/src/crypto/x509/root_linux.go">root_linux.go</a>
			
				<a href="/src/crypto/x509/root_unix.go">root_unix.go</a>
			
				<a href="/src/crypto/x509/sec1.go">sec1.go</a>
			
				<a href="/src/crypto/x509/verify.go">verify.go</a>
			
				<a href="/src/crypto/x509/x509.go">x509.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		<div id="pkg-callgraph" class="toggle" style="display: none">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Internal Call Graph section">Internal call graph ▹</h2>
		</div> <!-- .expanded -->
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Internal Call Graph section">Internal call graph ▾</h2>
			<p>
			  In the call graph viewer below, each node
			  is a function belonging to this package
			  and its children are the functions it
			  calls&mdash;perhaps dynamically.
			</p>
			<p>
			  The root nodes are the entry points of the
			  package: functions that may be called from
			  outside the package.
			  There may be non-exported or anonymous
			  functions among them if they are called
			  dynamically from another package.
			</p>
			<p>
			  Click a node to visit that function's source code.
			  From there you can visit its callers by
			  clicking its declaring <code>func</code>
			  token.
			</p>
			<p>
			  Functions may be omitted if they were
			  determined to be unreachable in the
			  particular programs or tests that were
			  analyzed.
			</p>
			<!-- Zero means show all package entry points. -->
			<ul style="margin-left: 0.5in" id="callgraph-0" class="treeview"></ul>
		</div>
		</div> <!-- #pkg-callgraph -->

		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<p>
ErrUnsupportedAlgorithm results from attempting to perform an operation that
involves algorithms that are not currently implemented.
</p>

				<pre>var <span id="ErrUnsupportedAlgorithm">ErrUnsupportedAlgorithm</span> = <a href="/pkg/errors/">errors</a>.<a href="/pkg/errors/#New">New</a>(&#34;x509: cannot verify signature: algorithm unimplemented&#34;)</pre>
			
				<p>
IncorrectPasswordError is returned when an incorrect password is detected.
</p>

				<pre>var <span id="IncorrectPasswordError">IncorrectPasswordError</span> = <a href="/pkg/errors/">errors</a>.<a href="/pkg/errors/#New">New</a>(&#34;x509: decryption password incorrect&#34;)</pre>
			
		
		
			
			
			<h2 id="CreateCertificate">func <a href="/src/crypto/x509/x509.go?s=66070:66187#L2050">CreateCertificate</a>
				<a class="permalink" href="#CreateCertificate">&#xb6;</a>
			</h2>
			<pre>func CreateCertificate(rand <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Reader">Reader</a>, template, parent *<a href="#Certificate">Certificate</a>, pub, priv interface{}) (cert []<a href="/pkg/builtin/#byte">byte</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
CreateCertificate creates a new X.509v3 certificate based on a template.
The following members of template are used: AuthorityKeyId,
BasicConstraintsValid, DNSNames, ExcludedDNSDomains, ExtKeyUsage,
IsCA, KeyUsage, MaxPathLen, MaxPathLenZero, NotAfter, NotBefore,
PermittedDNSDomains, PermittedDNSDomainsCritical, SerialNumber,
SignatureAlgorithm, Subject, SubjectKeyId, and UnknownExtKeyUsage.
</p>
<p>
The certificate is signed by parent. If parent is equal to template then the
certificate is self-signed. The parameter pub is the public key of the
signee and priv is the private key of the signer.
</p>
<p>
The returned slice is the certificate in DER encoding.
</p>
<p>
All keys types that are implemented via crypto.Signer are supported (This
includes *rsa.PublicKey and *ecdsa.PublicKey.)
</p>
<p>
The AuthorityKeyId will be taken from the SubjectKeyId of parent, if any,
unless the resulting certificate is self-signed. Otherwise the value from
template will be used.
</p>

			
			

		
			
			
			<h2 id="CreateCertificateRequest">func <a href="/src/crypto/x509/x509.go?s=75864:75981#L2366">CreateCertificateRequest</a>
				<a class="permalink" href="#CreateCertificateRequest">&#xb6;</a>
			</h2>
			<pre>func CreateCertificateRequest(rand <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Reader">Reader</a>, template *<a href="#CertificateRequest">CertificateRequest</a>, priv interface{}) (csr []<a href="/pkg/builtin/#byte">byte</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
CreateCertificateRequest creates a new certificate request based on a
template. The following members of template are used: Attributes, DNSNames,
EmailAddresses, ExtraExtensions, IPAddresses, URIs, SignatureAlgorithm, and
Subject. The private key is the private key of the signer.
</p>
<p>
The returned slice is the certificate request in DER encoding.
</p>
<p>
All keys types that are implemented via crypto.Signer are supported (This
includes *rsa.PublicKey and *ecdsa.PublicKey.)
</p>

			
			

		
			
			
			<h2 id="DecryptPEMBlock">func <a href="/src/crypto/x509/pem_decrypt.go?s=3143:3210#L105">DecryptPEMBlock</a>
				<a class="permalink" href="#DecryptPEMBlock">&#xb6;</a>
			</h2>
			<pre>func DecryptPEMBlock(b *<a href="/pkg/encoding/pem/">pem</a>.<a href="/pkg/encoding/pem/#Block">Block</a>, password []<a href="/pkg/builtin/#byte">byte</a>) ([]<a href="/pkg/builtin/#byte">byte</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
DecryptPEMBlock takes a password encrypted PEM block and the password used to
encrypt it and returns a slice of decrypted DER encoded bytes. It inspects
the DEK-Info header to determine the algorithm used for decryption. If no
DEK-Info header is present, an error is returned. If an incorrect password
is detected an IncorrectPasswordError is returned. Because of deficiencies
in the encrypted-PEM format, it&#39;s not always possible to detect an incorrect
password. In these cases no error will be returned but the decrypted DER
bytes will be random noise.
</p>

			
			

		
			
			
			<h2 id="EncryptPEMBlock">func <a href="/src/crypto/x509/pem_decrypt.go?s=5072:5184#L173">EncryptPEMBlock</a>
				<a class="permalink" href="#EncryptPEMBlock">&#xb6;</a>
			</h2>
			<pre>func EncryptPEMBlock(rand <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Reader">Reader</a>, blockType <a href="/pkg/builtin/#string">string</a>, data, password []<a href="/pkg/builtin/#byte">byte</a>, alg <a href="#PEMCipher">PEMCipher</a>) (*<a href="/pkg/encoding/pem/">pem</a>.<a href="/pkg/encoding/pem/#Block">Block</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
EncryptPEMBlock returns a PEM block of the specified type holding the
given DER-encoded data encrypted with the specified algorithm and
password.
</p>

			
			

		
			
			
			<h2 id="IsEncryptedPEMBlock">func <a href="/src/crypto/x509/pem_decrypt.go?s=2314:2357#L89">IsEncryptedPEMBlock</a>
				<a class="permalink" href="#IsEncryptedPEMBlock">&#xb6;</a>
			</h2>
			<pre>func IsEncryptedPEMBlock(b *<a href="/pkg/encoding/pem/">pem</a>.<a href="/pkg/encoding/pem/#Block">Block</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>
IsEncryptedPEMBlock returns if the PEM block is password encrypted.
</p>

			
			

		
			
			
			<h2 id="MarshalECPrivateKey">func <a href="/src/crypto/x509/sec1.go?s=1002:1065#L27">MarshalECPrivateKey</a>
				<a class="permalink" href="#MarshalECPrivateKey">&#xb6;</a>
			</h2>
			<pre>func MarshalECPrivateKey(key *<a href="/pkg/crypto/ecdsa/">ecdsa</a>.<a href="/pkg/crypto/ecdsa/#PrivateKey">PrivateKey</a>) ([]<a href="/pkg/builtin/#byte">byte</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
MarshalECPrivateKey marshals an EC private key into ASN.1, DER format.
</p>

			
			

		
			
			
			<h2 id="MarshalPKCS1PrivateKey">func <a href="/src/crypto/x509/pkcs1.go?s=2239:2294#L82">MarshalPKCS1PrivateKey</a>
				<a class="permalink" href="#MarshalPKCS1PrivateKey">&#xb6;</a>
			</h2>
			<pre>func MarshalPKCS1PrivateKey(key *<a href="/pkg/crypto/rsa/">rsa</a>.<a href="/pkg/crypto/rsa/#PrivateKey">PrivateKey</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>
MarshalPKCS1PrivateKey converts a private key to ASN.1 DER encoded form.
</p>

			
			

		
			
			
			<h2 id="MarshalPKCS1PublicKey">func <a href="/src/crypto/x509/pkcs1.go?s=3633:3686#L138">MarshalPKCS1PublicKey</a>
				<a class="permalink" href="#MarshalPKCS1PublicKey">&#xb6;</a>
			</h2>
			<pre>func MarshalPKCS1PublicKey(key *<a href="/pkg/crypto/rsa/">rsa</a>.<a href="/pkg/crypto/rsa/#PublicKey">PublicKey</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>
MarshalPKCS1PublicKey converts an RSA public key to PKCS#1, ASN.1 DER form.
</p>

			
			

		
			
			
			<h2 id="MarshalPKCS8PrivateKey">func <a href="/src/crypto/x509/pkcs8.go?s=1838:1898#L53">MarshalPKCS8PrivateKey</a>
				<a class="permalink" href="#MarshalPKCS8PrivateKey">&#xb6;</a>
			</h2>
			<pre>func MarshalPKCS8PrivateKey(key interface{}) ([]<a href="/pkg/builtin/#byte">byte</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
MarshalPKCS8PrivateKey converts a private key to PKCS#8 encoded form.
The following key types are supported: *rsa.PrivateKey, *ecdsa.PublicKey.
Unsupported key types result in an error.
</p>
<p>
See RFC 5208.
</p>

			
			

		
			
			
			<h2 id="MarshalPKIXPublicKey">func <a href="/src/crypto/x509/x509.go?s=3054:3112#L94">MarshalPKIXPublicKey</a>
				<a class="permalink" href="#MarshalPKIXPublicKey">&#xb6;</a>
			</h2>
			<pre>func MarshalPKIXPublicKey(pub interface{}) ([]<a href="/pkg/builtin/#byte">byte</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
MarshalPKIXPublicKey serialises a public key to DER-encoded PKIX format.
</p>

			
			

		
			
			
			<h2 id="ParseCRL">func <a href="/src/crypto/x509/x509.go?s=68780:68841#L2147">ParseCRL</a>
				<a class="permalink" href="#ParseCRL">&#xb6;</a>
			</h2>
			<pre>func ParseCRL(crlBytes []<a href="/pkg/builtin/#byte">byte</a>) (*<a href="/pkg/crypto/x509/pkix/">pkix</a>.<a href="/pkg/crypto/x509/pkix/#CertificateList">CertificateList</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
ParseCRL parses a CRL from the given bytes. It&#39;s often the case that PEM
encoded CRLs will appear where they should be DER encoded, so this function
will transparently handle PEM encoding as long as there isn&#39;t any leading
garbage.
</p>

			
			

		
			
			
			<h2 id="ParseCertificates">func <a href="/src/crypto/x509/x509.go?s=51734:51797#L1574">ParseCertificates</a>
				<a class="permalink" href="#ParseCertificates">&#xb6;</a>
			</h2>
			<pre>func ParseCertificates(asn1Data []<a href="/pkg/builtin/#byte">byte</a>) ([]*<a href="#Certificate">Certificate</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
ParseCertificates parses one or more certificates from the given ASN.1 DER
data. The certificates must be concatenated with no intermediate padding.
</p>

			
			

		
			
			
			<h2 id="ParseDERCRL">func <a href="/src/crypto/x509/x509.go?s=69098:69162#L2158">ParseDERCRL</a>
				<a class="permalink" href="#ParseDERCRL">&#xb6;</a>
			</h2>
			<pre>func ParseDERCRL(derBytes []<a href="/pkg/builtin/#byte">byte</a>) (*<a href="/pkg/crypto/x509/pkix/">pkix</a>.<a href="/pkg/crypto/x509/pkix/#CertificateList">CertificateList</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
ParseDERCRL parses a DER encoded CRL from the given bytes.
</p>

			
			

		
			
			
			<h2 id="ParseECPrivateKey">func <a href="/src/crypto/x509/sec1.go?s=825:886#L22">ParseECPrivateKey</a>
				<a class="permalink" href="#ParseECPrivateKey">&#xb6;</a>
			</h2>
			<pre>func ParseECPrivateKey(der []<a href="/pkg/builtin/#byte">byte</a>) (*<a href="/pkg/crypto/ecdsa/">ecdsa</a>.<a href="/pkg/crypto/ecdsa/#PrivateKey">PrivateKey</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
ParseECPrivateKey parses an ASN.1 Elliptic Curve Private Key Structure.
</p>

			
			

		
			
			
			<h2 id="ParsePKCS1PrivateKey">func <a href="/src/crypto/x509/pkcs1.go?s=1067:1129#L35">ParsePKCS1PrivateKey</a>
				<a class="permalink" href="#ParsePKCS1PrivateKey">&#xb6;</a>
			</h2>
			<pre>func ParsePKCS1PrivateKey(der []<a href="/pkg/builtin/#byte">byte</a>) (*<a href="/pkg/crypto/rsa/">rsa</a>.<a href="/pkg/crypto/rsa/#PrivateKey">PrivateKey</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
ParsePKCS1PrivateKey returns an RSA private key from its ASN.1 PKCS#1 DER encoded form.
</p>

			
			

		
			
			
			<h2 id="ParsePKCS1PublicKey">func <a href="/src/crypto/x509/pkcs1.go?s=3033:3093#L114">ParsePKCS1PublicKey</a>
				<a class="permalink" href="#ParsePKCS1PublicKey">&#xb6;</a>
			</h2>
			<pre>func ParsePKCS1PublicKey(der []<a href="/pkg/builtin/#byte">byte</a>) (*<a href="/pkg/crypto/rsa/">rsa</a>.<a href="/pkg/crypto/rsa/#PublicKey">PublicKey</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
ParsePKCS1PublicKey parses a PKCS#1 public key in ASN.1 DER form.
</p>

			
			

		
			
			
			<h2 id="ParsePKCS8PrivateKey">func <a href="/src/crypto/x509/pkcs8.go?s=610:676#L18">ParsePKCS8PrivateKey</a>
				<a class="permalink" href="#ParsePKCS8PrivateKey">&#xb6;</a>
			</h2>
			<pre>func ParsePKCS8PrivateKey(der []<a href="/pkg/builtin/#byte">byte</a>) (key interface{}, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
ParsePKCS8PrivateKey parses an unencrypted, PKCS#8 private key.
See RFC 5208.
</p>

			
			

		
			
			
			<h2 id="ParsePKIXPublicKey">func <a href="/src/crypto/x509/x509.go?s=1352:1421#L45">ParsePKIXPublicKey</a>
				<a class="permalink" href="#ParsePKIXPublicKey">&#xb6;</a>
			</h2>
			<pre>func ParsePKIXPublicKey(derBytes []<a href="/pkg/builtin/#byte">byte</a>) (pub interface{}, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
ParsePKIXPublicKey parses a DER encoded public key. These values are
typically found in PEM blocks with &#34;BEGIN PUBLIC KEY&#34;.
</p>
<p>
Supported key types include RSA, DSA, and ECDSA. Unknown key
types result in an error.
</p>
<p>
On success, pub will be of type *rsa.PublicKey, *dsa.PublicKey,
or *ecdsa.PublicKey.
</p>

			<div id="example_ParsePKIXPublicKey" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;crypto/dsa&#34;
	&#34;crypto/ecdsa&#34;
	&#34;crypto/rsa&#34;
	&#34;crypto/x509&#34;
	&#34;encoding/pem&#34;
	&#34;fmt&#34;
)

func main() {
	const pubPEM = `
-----BEGIN PUBLIC KEY-----
MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAlRuRnThUjU8/prwYxbty
WPT9pURI3lbsKMiB6Fn/VHOKE13p4D8xgOCADpdRagdT6n4etr9atzDKUSvpMtR3
CP5noNc97WiNCggBjVWhs7szEe8ugyqF23XwpHQ6uV1LKH50m92MbOWfCtjU9p/x
qhNpQQ1AZhqNy5Gevap5k8XzRmjSldNAFZMY7Yv3Gi+nyCwGwpVtBUwhuLzgNFK/
yDtw2WcWmUU7NuC8Q6MWvPebxVtCfVp/iQU6q60yyt6aGOBkhAX0LpKAEhKidixY
nP9PNVBvxgu3XZ4P36gZV6+ummKdBVnc3NqwBLu5+CcdRdusmHPHd5pHf4/38Z3/
6qU2a/fPvWzceVTEgZ47QjFMTCTmCwNt29cvi7zZeQzjtwQgn4ipN9NibRH/Ax/q
TbIzHfrJ1xa2RteWSdFjwtxi9C20HUkjXSeI4YlzQMH0fPX6KCE7aVePTOnB69I/
a9/q96DiXZajwlpq3wFctrs1oXqBp5DVrCIj8hU2wNgB7LtQ1mCtsYz//heai0K9
PhE4X6hiE0YmeAZjR0uHl8M/5aW9xCoJ72+12kKpWAa0SFRWLy6FejNYCYpkupVJ
yecLk/4L1W0l6jQQZnWErXZYe0PNFcmwGXy1Rep83kfBRNKRy5tvocalLlwXLdUk
AIU+2GKjyT3iMuzZxxFxPFMCAwEAAQ==
-----END PUBLIC KEY-----`

	block, _ := pem.Decode([]byte(pubPEM))
	if block == nil {
		panic(&#34;failed to parse PEM block containing the public key&#34;)
	}

	pub, err := x509.ParsePKIXPublicKey(block.Bytes)
	if err != nil {
		panic(&#34;failed to parse DER encoded public key: &#34; + err.Error())
	}

	switch pub := pub.(type) {
	case *rsa.PublicKey:
		fmt.Println(&#34;pub is of type RSA:&#34;, pub)
	case *dsa.PublicKey:
		fmt.Println(&#34;pub is of type DSA:&#34;, pub)
	case *ecdsa.PublicKey:
		fmt.Println(&#34;pub is of type ECDSA:&#34;, pub)
	default:
		panic(&#34;unknown type of public key&#34;)
	}
}
</textarea></div>
				<div class="output"><pre></pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
		
			
			
			<h2 id="CertPool">type <a href="/src/crypto/x509/cert_pool.go?s=261:382#L4">CertPool</a>
				<a class="permalink" href="#CertPool">&#xb6;</a>
			</h2>
			<p>
CertPool is a set of certificates.
</p>

			<pre>type CertPool struct {
        <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewCertPool">func <a href="/src/crypto/x509/cert_pool.go?s=430:458#L11">NewCertPool</a>
					<a class="permalink" href="#NewCertPool">&#xb6;</a>
				</h3>
				<pre>func NewCertPool() *<a href="#CertPool">CertPool</a></pre>
				<p>
NewCertPool returns a new, empty CertPool.
</p>

				
				
			
				
				<h3 id="SystemCertPool">func <a href="/src/crypto/x509/cert_pool.go?s=730:770#L22">SystemCertPool</a>
					<a class="permalink" href="#SystemCertPool">&#xb6;</a>
				</h3>
				<pre>func SystemCertPool() (*<a href="#CertPool">CertPool</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SystemCertPool returns a copy of the system cert pool.
</p>
<p>
Any mutations to the returned pool are not written to disk and do
not affect any other pool.
</p>

				
				
			

			
				
				<h3 id="CertPool.AddCert">func (*CertPool) <a href="/src/crypto/x509/cert_pool.go?s=1993:2038#L75">AddCert</a>
					<a class="permalink" href="#CertPool.AddCert">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="#CertPool">CertPool</a>) AddCert(cert *<a href="#Certificate">Certificate</a>)</pre>
				<p>
AddCert adds a certificate to a pool.
</p>

				
				
				
			
				
				<h3 id="CertPool.AppendCertsFromPEM">func (*CertPool) <a href="/src/crypto/x509/cert_pool.go?s=2791:2855#L102">AppendCertsFromPEM</a>
					<a class="permalink" href="#CertPool.AppendCertsFromPEM">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="#CertPool">CertPool</a>) AppendCertsFromPEM(pemCerts []<a href="/pkg/builtin/#byte">byte</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
AppendCertsFromPEM attempts to parse a series of PEM encoded certificates.
It appends any certificates found to s and reports whether any certificates
were successfully parsed.
</p>
<p>
On many Linux systems, /etc/ssl/cert.pem will contain the system wide set
of root CAs in a format suitable for this function.
</p>

				
				
				
			
				
				<h3 id="CertPool.Subjects">func (*CertPool) <a href="/src/crypto/x509/cert_pool.go?s=3282:3320#L127">Subjects</a>
					<a class="permalink" href="#CertPool.Subjects">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="#CertPool">CertPool</a>) Subjects() [][]<a href="/pkg/builtin/#byte">byte</a></pre>
				<p>
Subjects returns a list of the DER-encoded subjects of
all of the certificates in the pool.
</p>

				
				
				
			
		
			
			
			<h2 id="Certificate">type <a href="/src/crypto/x509/x509.go?s=20488:24535#L623">Certificate</a>
				<a class="permalink" href="#Certificate">&#xb6;</a>
			</h2>
			<p>
A Certificate represents an X.509 certificate.
</p>

			<pre>type Certificate struct {
<span id="Certificate.Raw"></span>        Raw                     []<a href="/pkg/builtin/#byte">byte</a> <span class="comment">// Complete ASN.1 DER content (certificate, signature algorithm and signature).</span>
<span id="Certificate.RawTBSCertificate"></span>        RawTBSCertificate       []<a href="/pkg/builtin/#byte">byte</a> <span class="comment">// Certificate part of raw ASN.1 DER content.</span>
<span id="Certificate.RawSubjectPublicKeyInfo"></span>        RawSubjectPublicKeyInfo []<a href="/pkg/builtin/#byte">byte</a> <span class="comment">// DER encoded SubjectPublicKeyInfo.</span>
<span id="Certificate.RawSubject"></span>        RawSubject              []<a href="/pkg/builtin/#byte">byte</a> <span class="comment">// DER encoded Subject</span>
<span id="Certificate.RawIssuer"></span>        RawIssuer               []<a href="/pkg/builtin/#byte">byte</a> <span class="comment">// DER encoded Issuer</span>

<span id="Certificate.Signature"></span>        Signature          []<a href="/pkg/builtin/#byte">byte</a>
<span id="Certificate.SignatureAlgorithm"></span>        SignatureAlgorithm <a href="#SignatureAlgorithm">SignatureAlgorithm</a>

<span id="Certificate.PublicKeyAlgorithm"></span>        PublicKeyAlgorithm <a href="#PublicKeyAlgorithm">PublicKeyAlgorithm</a>
<span id="Certificate.PublicKey"></span>        PublicKey          interface{}

<span id="Certificate.Version"></span>        Version             <a href="/pkg/builtin/#int">int</a>
<span id="Certificate.SerialNumber"></span>        SerialNumber        *<a href="/pkg/math/big/">big</a>.<a href="/pkg/math/big/#Int">Int</a>
<span id="Certificate.Issuer"></span>        Issuer              <a href="/pkg/crypto/x509/pkix/">pkix</a>.<a href="/pkg/crypto/x509/pkix/#Name">Name</a>
<span id="Certificate.Subject"></span>        Subject             <a href="/pkg/crypto/x509/pkix/">pkix</a>.<a href="/pkg/crypto/x509/pkix/#Name">Name</a>
<span id="Certificate.NotBefore"></span>        NotBefore, NotAfter <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a> <span class="comment">// Validity bounds.</span>
<span id="Certificate.KeyUsage"></span>        KeyUsage            <a href="#KeyUsage">KeyUsage</a>

<span id="Certificate.Extensions"></span>        <span class="comment">// Extensions contains raw X.509 extensions. When parsing certificates,</span>
        <span class="comment">// this can be used to extract non-critical extensions that are not</span>
        <span class="comment">// parsed by this package. When marshaling certificates, the Extensions</span>
        <span class="comment">// field is ignored, see ExtraExtensions.</span>
        Extensions []<a href="/pkg/crypto/x509/pkix/">pkix</a>.<a href="/pkg/crypto/x509/pkix/#Extension">Extension</a>

<span id="Certificate.ExtraExtensions"></span>        <span class="comment">// ExtraExtensions contains extensions to be copied, raw, into any</span>
        <span class="comment">// marshaled certificates. Values override any extensions that would</span>
        <span class="comment">// otherwise be produced based on the other fields. The ExtraExtensions</span>
        <span class="comment">// field is not populated when parsing certificates, see Extensions.</span>
        ExtraExtensions []<a href="/pkg/crypto/x509/pkix/">pkix</a>.<a href="/pkg/crypto/x509/pkix/#Extension">Extension</a>

<span id="Certificate.UnhandledCriticalExtensions"></span>        <span class="comment">// UnhandledCriticalExtensions contains a list of extension IDs that</span>
        <span class="comment">// were not (fully) processed when parsing. Verify will fail if this</span>
        <span class="comment">// slice is non-empty, unless verification is delegated to an OS</span>
        <span class="comment">// library which understands all the critical extensions.</span>
        <span class="comment">//</span>
        <span class="comment">// Users can access these extensions using Extensions and can remove</span>
        <span class="comment">// elements from this slice if they believe that they have been</span>
        <span class="comment">// handled.</span>
        UnhandledCriticalExtensions []<a href="/pkg/encoding/asn1/">asn1</a>.<a href="/pkg/encoding/asn1/#ObjectIdentifier">ObjectIdentifier</a>

<span id="Certificate.ExtKeyUsage"></span>        ExtKeyUsage        []<a href="#ExtKeyUsage">ExtKeyUsage</a>           <span class="comment">// Sequence of extended key usages.</span>
<span id="Certificate.UnknownExtKeyUsage"></span>        UnknownExtKeyUsage []<a href="/pkg/encoding/asn1/">asn1</a>.<a href="/pkg/encoding/asn1/#ObjectIdentifier">ObjectIdentifier</a> <span class="comment">// Encountered extended key usages unknown to this package.</span>

<span id="Certificate.BasicConstraintsValid"></span>        <span class="comment">// BasicConstraintsValid indicates whether IsCA, MaxPathLen,</span>
        <span class="comment">// and MaxPathLenZero are valid.</span>
        BasicConstraintsValid <a href="/pkg/builtin/#bool">bool</a>
<span id="Certificate.IsCA"></span>        IsCA                  <a href="/pkg/builtin/#bool">bool</a>

<span id="Certificate.MaxPathLen"></span>        <span class="comment">// MaxPathLen and MaxPathLenZero indicate the presence and</span>
        <span class="comment">// value of the BasicConstraints&#39; &#34;pathLenConstraint&#34;.</span>
        <span class="comment">//</span>
        <span class="comment">// When parsing a certificate, a positive non-zero MaxPathLen</span>
        <span class="comment">// means that the field was specified, -1 means it was unset,</span>
        <span class="comment">// and MaxPathLenZero being true mean that the field was</span>
        <span class="comment">// explicitly set to zero. The case of MaxPathLen==0 with MaxPathLenZero==false</span>
        <span class="comment">// should be treated equivalent to -1 (unset).</span>
        <span class="comment">//</span>
        <span class="comment">// When generating a certificate, an unset pathLenConstraint</span>
        <span class="comment">// can be requested with either MaxPathLen == -1 or using the</span>
        <span class="comment">// zero value for both MaxPathLen and MaxPathLenZero.</span>
        MaxPathLen <a href="/pkg/builtin/#int">int</a>
<span id="Certificate.MaxPathLenZero"></span>        <span class="comment">// MaxPathLenZero indicates that BasicConstraintsValid==true</span>
        <span class="comment">// and MaxPathLen==0 should be interpreted as an actual</span>
        <span class="comment">// maximum path length of zero. Otherwise, that combination is</span>
        <span class="comment">// interpreted as MaxPathLen not being set.</span>
        MaxPathLenZero <a href="/pkg/builtin/#bool">bool</a>

<span id="Certificate.SubjectKeyId"></span>        SubjectKeyId   []<a href="/pkg/builtin/#byte">byte</a>
<span id="Certificate.AuthorityKeyId"></span>        AuthorityKeyId []<a href="/pkg/builtin/#byte">byte</a>

        <span class="comment">// RFC 5280, 4.2.2.1 (Authority Information Access)</span>
<span id="Certificate.OCSPServer"></span>        OCSPServer            []<a href="/pkg/builtin/#string">string</a>
<span id="Certificate.IssuingCertificateURL"></span>        IssuingCertificateURL []<a href="/pkg/builtin/#string">string</a>

        <span class="comment">// Subject Alternate Name values. (Note that these values may not be valid</span>
        <span class="comment">// if invalid values were contained within a parsed certificate. For</span>
        <span class="comment">// example, an element of DNSNames may not be a valid DNS domain name.)</span>
<span id="Certificate.DNSNames"></span>        DNSNames       []<a href="/pkg/builtin/#string">string</a>
<span id="Certificate.EmailAddresses"></span>        EmailAddresses []<a href="/pkg/builtin/#string">string</a>
<span id="Certificate.IPAddresses"></span>        IPAddresses    []<a href="/pkg/net/">net</a>.<a href="/pkg/net/#IP">IP</a>
<span id="Certificate.URIs"></span>        URIs           []*<a href="/pkg/net/url/">url</a>.<a href="/pkg/net/url/#URL">URL</a>

        <span class="comment">// Name constraints</span>
<span id="Certificate.PermittedDNSDomainsCritical"></span>        PermittedDNSDomainsCritical <a href="/pkg/builtin/#bool">bool</a> <span class="comment">// if true then the name constraints are marked critical.</span>
<span id="Certificate.PermittedDNSDomains"></span>        PermittedDNSDomains         []<a href="/pkg/builtin/#string">string</a>
<span id="Certificate.ExcludedDNSDomains"></span>        ExcludedDNSDomains          []<a href="/pkg/builtin/#string">string</a>
<span id="Certificate.PermittedIPRanges"></span>        PermittedIPRanges           []*<a href="/pkg/net/">net</a>.<a href="/pkg/net/#IPNet">IPNet</a>
<span id="Certificate.ExcludedIPRanges"></span>        ExcludedIPRanges            []*<a href="/pkg/net/">net</a>.<a href="/pkg/net/#IPNet">IPNet</a>
<span id="Certificate.PermittedEmailAddresses"></span>        PermittedEmailAddresses     []<a href="/pkg/builtin/#string">string</a>
<span id="Certificate.ExcludedEmailAddresses"></span>        ExcludedEmailAddresses      []<a href="/pkg/builtin/#string">string</a>
<span id="Certificate.PermittedURIDomains"></span>        PermittedURIDomains         []<a href="/pkg/builtin/#string">string</a>
<span id="Certificate.ExcludedURIDomains"></span>        ExcludedURIDomains          []<a href="/pkg/builtin/#string">string</a>

        <span class="comment">// CRL Distribution Points</span>
<span id="Certificate.CRLDistributionPoints"></span>        CRLDistributionPoints []<a href="/pkg/builtin/#string">string</a>

<span id="Certificate.PolicyIdentifiers"></span>        PolicyIdentifiers []<a href="/pkg/encoding/asn1/">asn1</a>.<a href="/pkg/encoding/asn1/#ObjectIdentifier">ObjectIdentifier</a>
}</pre>

			

			

			
			
			

			
				
				<h3 id="ParseCertificate">func <a href="/src/crypto/x509/x509.go?s=51298:51358#L1559">ParseCertificate</a>
					<a class="permalink" href="#ParseCertificate">&#xb6;</a>
				</h3>
				<pre>func ParseCertificate(asn1Data []<a href="/pkg/builtin/#byte">byte</a>) (*<a href="#Certificate">Certificate</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ParseCertificate parses a single certificate from the given ASN.1 DER data.
</p>

				
				
			

			
				
				<h3 id="Certificate.CheckCRLSignature">func (*Certificate) <a href="/src/crypto/x509/x509.go?s=32217:32289#L936">CheckCRLSignature</a>
					<a class="permalink" href="#Certificate.CheckCRLSignature">&#xb6;</a>
				</h3>
				<pre>func (c *<a href="#Certificate">Certificate</a>) CheckCRLSignature(crl *<a href="/pkg/crypto/x509/pkix/">pkix</a>.<a href="/pkg/crypto/x509/pkix/#CertificateList">CertificateList</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>
CheckCRLSignature checks that the signature in crl is from c.
</p>

				
				
				
			
				
				<h3 id="Certificate.CheckSignature">func (*Certificate) <a href="/src/crypto/x509/x509.go?s=29024:29117#L831">CheckSignature</a>
					<a class="permalink" href="#Certificate.CheckSignature">&#xb6;</a>
				</h3>
				<pre>func (c *<a href="#Certificate">Certificate</a>) CheckSignature(algo <a href="#SignatureAlgorithm">SignatureAlgorithm</a>, signed, signature []<a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>
CheckSignature verifies that signature is a valid signature over signed from
c&#39;s public key.
</p>

				
				
				
			
				
				<h3 id="Certificate.CheckSignatureFrom">func (*Certificate) <a href="/src/crypto/x509/x509.go?s=27962:28029#L803">CheckSignatureFrom</a>
					<a class="permalink" href="#Certificate.CheckSignatureFrom">&#xb6;</a>
				</h3>
				<pre>func (c *<a href="#Certificate">Certificate</a>) CheckSignatureFrom(parent *<a href="#Certificate">Certificate</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>
CheckSignatureFrom verifies that the signature on c is a valid signature
from parent.
</p>

				
				
				
			
				
				<h3 id="Certificate.CreateCRL">func (*Certificate) <a href="/src/crypto/x509/x509.go?s=69527:69684#L2170">CreateCRL</a>
					<a class="permalink" href="#Certificate.CreateCRL">&#xb6;</a>
				</h3>
				<pre>func (c *<a href="#Certificate">Certificate</a>) CreateCRL(rand <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Reader">Reader</a>, priv interface{}, revokedCerts []<a href="/pkg/crypto/x509/pkix/">pkix</a>.<a href="/pkg/crypto/x509/pkix/#RevokedCertificate">RevokedCertificate</a>, now, expiry <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) (crlBytes []<a href="/pkg/builtin/#byte">byte</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
CreateCRL returns a DER encoded CRL, signed by this Certificate, that
contains the given list of revoked certificates.
</p>

				
				
				
			
				
				<h3 id="Certificate.Equal">func (*Certificate) <a href="/src/crypto/x509/x509.go?s=25374:25426#L744">Equal</a>
					<a class="permalink" href="#Certificate.Equal">&#xb6;</a>
				</h3>
				<pre>func (c *<a href="#Certificate">Certificate</a>) Equal(other *<a href="#Certificate">Certificate</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
				
			
				
				<h3 id="Certificate.Verify">func (*Certificate) <a href="/src/crypto/x509/verify.go?s=26416:26501#L816">Verify</a>
					<a class="permalink" href="#Certificate.Verify">&#xb6;</a>
				</h3>
				<pre>func (c *<a href="#Certificate">Certificate</a>) Verify(opts <a href="#VerifyOptions">VerifyOptions</a>) (chains [][]*<a href="#Certificate">Certificate</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Verify attempts to verify c by building one or more chains from c to a
certificate in opts.Roots, using certificates in opts.Intermediates if
needed. If successful, it returns one or more chains where the first
element of the chain is c and the last element is from opts.Roots.
</p>
<p>
If opts.Roots is nil and system roots are unavailable the returned error
will be of type SystemRootsError.
</p>
<p>
Name constraints in the intermediates will be applied to all names claimed
in the chain, not just opts.DNSName. Thus it is invalid for a leaf to claim
example.com if an intermediate doesn&#39;t permit it, even if example.com is not
the name being validated. Note that DirectoryName constraints are not
supported.
</p>
<p>
Extended Key Usage values are enforced down a chain, so an intermediate or
root that enumerates EKUs prevents a leaf from asserting an EKU not in that
list.
</p>
<p>
WARNING: this function doesn&#39;t do any revocation checking.
</p>

				
				<div id="example_Certificate_Verify" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;crypto/x509&#34;
	&#34;encoding/pem&#34;
)

func main() {
	// Verifying with a custom list of root certificates.

	const rootPEM = `
-----BEGIN CERTIFICATE-----
MIIEBDCCAuygAwIBAgIDAjppMA0GCSqGSIb3DQEBBQUAMEIxCzAJBgNVBAYTAlVT
MRYwFAYDVQQKEw1HZW9UcnVzdCBJbmMuMRswGQYDVQQDExJHZW9UcnVzdCBHbG9i
YWwgQ0EwHhcNMTMwNDA1MTUxNTU1WhcNMTUwNDA0MTUxNTU1WjBJMQswCQYDVQQG
EwJVUzETMBEGA1UEChMKR29vZ2xlIEluYzElMCMGA1UEAxMcR29vZ2xlIEludGVy
bmV0IEF1dGhvcml0eSBHMjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEB
AJwqBHdc2FCROgajguDYUEi8iT/xGXAaiEZ+4I/F8YnOIe5a/mENtzJEiaB0C1NP
VaTOgmKV7utZX8bhBYASxF6UP7xbSDj0U/ck5vuR6RXEz/RTDfRK/J9U3n2+oGtv
h8DQUB8oMANA2ghzUWx//zo8pzcGjr1LEQTrfSTe5vn8MXH7lNVg8y5Kr0LSy+rE
ahqyzFPdFUuLH8gZYR/Nnag+YyuENWllhMgZxUYi+FOVvuOAShDGKuy6lyARxzmZ
EASg8GF6lSWMTlJ14rbtCMoU/M4iarNOz0YDl5cDfsCx3nuvRTPPuj5xt970JSXC
DTWJnZ37DhF5iR43xa+OcmkCAwEAAaOB+zCB+DAfBgNVHSMEGDAWgBTAephojYn7
qwVkDBF9qn1luMrMTjAdBgNVHQ4EFgQUSt0GFhu89mi1dvWBtrtiGrpagS8wEgYD
VR0TAQH/BAgwBgEB/wIBADAOBgNVHQ8BAf8EBAMCAQYwOgYDVR0fBDMwMTAvoC2g
K4YpaHR0cDovL2NybC5nZW90cnVzdC5jb20vY3Jscy9ndGdsb2JhbC5jcmwwPQYI
KwYBBQUHAQEEMTAvMC0GCCsGAQUFBzABhiFodHRwOi8vZ3RnbG9iYWwtb2NzcC5n
ZW90cnVzdC5jb20wFwYDVR0gBBAwDjAMBgorBgEEAdZ5AgUBMA0GCSqGSIb3DQEB
BQUAA4IBAQA21waAESetKhSbOHezI6B1WLuxfoNCunLaHtiONgaX4PCVOzf9G0JY
/iLIa704XtE7JW4S615ndkZAkNoUyHgN7ZVm2o6Gb4ChulYylYbc3GrKBIxbf/a/
zG+FA1jDaFETzf3I93k9mTXwVqO94FntT0QJo544evZG0R0SnU++0ED8Vf4GXjza
HFa9llF7b1cq26KqltyMdMKVvvBulRP/F/A8rLIQjcxz++iPAsbw+zOzlTvjwsto
WHPbqCRiOwY1nQ2pM714A5AuTHhdUDqB1O6gyHA43LL5Z/qHQF1hwFGPa4NrzQU6
yuGnBXj8ytqU0CwIPX4WecigUCAkVDNx
-----END CERTIFICATE-----`

	const certPEM = `
-----BEGIN CERTIFICATE-----
MIIDujCCAqKgAwIBAgIIE31FZVaPXTUwDQYJKoZIhvcNAQEFBQAwSTELMAkGA1UE
BhMCVVMxEzARBgNVBAoTCkdvb2dsZSBJbmMxJTAjBgNVBAMTHEdvb2dsZSBJbnRl
cm5ldCBBdXRob3JpdHkgRzIwHhcNMTQwMTI5MTMyNzQzWhcNMTQwNTI5MDAwMDAw
WjBpMQswCQYDVQQGEwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwN
TW91bnRhaW4gVmlldzETMBEGA1UECgwKR29vZ2xlIEluYzEYMBYGA1UEAwwPbWFp
bC5nb29nbGUuY29tMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEfRrObuSW5T7q
5CnSEqefEmtH4CCv6+5EckuriNr1CjfVvqzwfAhopXkLrq45EQm8vkmf7W96XJhC
7ZM0dYi1/qOCAU8wggFLMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAa
BgNVHREEEzARgg9tYWlsLmdvb2dsZS5jb20wCwYDVR0PBAQDAgeAMGgGCCsGAQUF
BwEBBFwwWjArBggrBgEFBQcwAoYfaHR0cDovL3BraS5nb29nbGUuY29tL0dJQUcy
LmNydDArBggrBgEFBQcwAYYfaHR0cDovL2NsaWVudHMxLmdvb2dsZS5jb20vb2Nz
cDAdBgNVHQ4EFgQUiJxtimAuTfwb+aUtBn5UYKreKvMwDAYDVR0TAQH/BAIwADAf
BgNVHSMEGDAWgBRK3QYWG7z2aLV29YG2u2IaulqBLzAXBgNVHSAEEDAOMAwGCisG
AQQB1nkCBQEwMAYDVR0fBCkwJzAloCOgIYYfaHR0cDovL3BraS5nb29nbGUuY29t
L0dJQUcyLmNybDANBgkqhkiG9w0BAQUFAAOCAQEAH6RYHxHdcGpMpFE3oxDoFnP+
gtuBCHan2yE2GRbJ2Cw8Lw0MmuKqHlf9RSeYfd3BXeKkj1qO6TVKwCh+0HdZk283
TZZyzmEOyclm3UGFYe82P/iDFt+CeQ3NpmBg+GoaVCuWAARJN/KfglbLyyYygcQq
0SgeDh8dRKUiaW3HQSoYvTvdTuqzwK4CXsr3b5/dAOY8uMuG/IAR3FgwTbZ1dtoW
RvOTa8hYiU6A475WuZKyEHcwnGYe57u2I2KbMgcKjPniocj4QzgYsVAVKW3IwaOh
yE+vPxsiUkvQHdO2fojCkY8jg70jxM+gu59tPDNbw3Uh/2Ij310FgTHsnGQMyA==
-----END CERTIFICATE-----`

	// First, create the set of root certificates. For this example we only
	// have one. It&#39;s also possible to omit this in order to use the
	// default root set of the current operating system.
	roots := x509.NewCertPool()
	ok := roots.AppendCertsFromPEM([]byte(rootPEM))
	if !ok {
		panic(&#34;failed to parse root certificate&#34;)
	}

	block, _ := pem.Decode([]byte(certPEM))
	if block == nil {
		panic(&#34;failed to parse certificate PEM&#34;)
	}
	cert, err := x509.ParseCertificate(block.Bytes)
	if err != nil {
		panic(&#34;failed to parse certificate: &#34; + err.Error())
	}

	opts := x509.VerifyOptions{
		DNSName: &#34;mail.google.com&#34;,
		Roots:   roots,
	}

	if _, err := cert.Verify(opts); err != nil {
		panic(&#34;failed to verify certificate: &#34; + err.Error())
	}
}
</textarea></div>
				<div class="output"><pre></pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

				
			
				
				<h3 id="Certificate.VerifyHostname">func (*Certificate) <a href="/src/crypto/x509/verify.go?s=31838:31890#L1039">VerifyHostname</a>
					<a class="permalink" href="#Certificate.VerifyHostname">&#xb6;</a>
				</h3>
				<pre>func (c *<a href="#Certificate">Certificate</a>) VerifyHostname(h <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>
VerifyHostname returns nil if c is a valid certificate for the named host.
Otherwise it returns an error describing the mismatch.
</p>

				
				
				
			
		
			
			
			<h2 id="CertificateInvalidError">type <a href="/src/crypto/x509/verify.go?s=2277:2374#L56">CertificateInvalidError</a>
				<a class="permalink" href="#CertificateInvalidError">&#xb6;</a>
			</h2>
			<p>
CertificateInvalidError results when an odd error occurs. Users of this
library probably want to handle all these errors uniformly.
</p>

			<pre>type CertificateInvalidError struct {
<span id="CertificateInvalidError.Cert"></span>        Cert   *<a href="#Certificate">Certificate</a>
<span id="CertificateInvalidError.Reason"></span>        Reason <a href="#InvalidReason">InvalidReason</a>
<span id="CertificateInvalidError.Detail"></span>        Detail <a href="/pkg/builtin/#string">string</a>
}</pre>

			

			

			
			
			

			

			
				
				<h3 id="CertificateInvalidError.Error">func (CertificateInvalidError) <a href="/src/crypto/x509/verify.go?s=2376:2423#L62">Error</a>
					<a class="permalink" href="#CertificateInvalidError.Error">&#xb6;</a>
				</h3>
				<pre>func (e <a href="#CertificateInvalidError">CertificateInvalidError</a>) Error() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="CertificateRequest">type <a href="/src/crypto/x509/x509.go?s=71278:72618#L2231">CertificateRequest</a>
				<a class="permalink" href="#CertificateRequest">&#xb6;</a>
			</h2>
			<p>
CertificateRequest represents a PKCS #10, certificate signature request.
</p>

			<pre>type CertificateRequest struct {
<span id="CertificateRequest.Raw"></span>        Raw                      []<a href="/pkg/builtin/#byte">byte</a> <span class="comment">// Complete ASN.1 DER content (CSR, signature algorithm and signature).</span>
<span id="CertificateRequest.RawTBSCertificateRequest"></span>        RawTBSCertificateRequest []<a href="/pkg/builtin/#byte">byte</a> <span class="comment">// Certificate request info part of raw ASN.1 DER content.</span>
<span id="CertificateRequest.RawSubjectPublicKeyInfo"></span>        RawSubjectPublicKeyInfo  []<a href="/pkg/builtin/#byte">byte</a> <span class="comment">// DER encoded SubjectPublicKeyInfo.</span>
<span id="CertificateRequest.RawSubject"></span>        RawSubject               []<a href="/pkg/builtin/#byte">byte</a> <span class="comment">// DER encoded Subject.</span>

<span id="CertificateRequest.Version"></span>        Version            <a href="/pkg/builtin/#int">int</a>
<span id="CertificateRequest.Signature"></span>        Signature          []<a href="/pkg/builtin/#byte">byte</a>
<span id="CertificateRequest.SignatureAlgorithm"></span>        SignatureAlgorithm <a href="#SignatureAlgorithm">SignatureAlgorithm</a>

<span id="CertificateRequest.PublicKeyAlgorithm"></span>        PublicKeyAlgorithm <a href="#PublicKeyAlgorithm">PublicKeyAlgorithm</a>
<span id="CertificateRequest.PublicKey"></span>        PublicKey          interface{}

<span id="CertificateRequest.Subject"></span>        Subject <a href="/pkg/crypto/x509/pkix/">pkix</a>.<a href="/pkg/crypto/x509/pkix/#Name">Name</a>

<span id="CertificateRequest.Attributes"></span>        <span class="comment">// Attributes is the dried husk of a bug and shouldn&#39;t be used.</span>
        Attributes []<a href="/pkg/crypto/x509/pkix/">pkix</a>.<a href="/pkg/crypto/x509/pkix/#AttributeTypeAndValueSET">AttributeTypeAndValueSET</a>

<span id="CertificateRequest.Extensions"></span>        <span class="comment">// Extensions contains raw X.509 extensions. When parsing CSRs, this</span>
        <span class="comment">// can be used to extract extensions that are not parsed by this</span>
        <span class="comment">// package.</span>
        Extensions []<a href="/pkg/crypto/x509/pkix/">pkix</a>.<a href="/pkg/crypto/x509/pkix/#Extension">Extension</a>

<span id="CertificateRequest.ExtraExtensions"></span>        <span class="comment">// ExtraExtensions contains extensions to be copied, raw, into any</span>
        <span class="comment">// marshaled CSR. Values override any extensions that would otherwise</span>
        <span class="comment">// be produced based on the other fields but are overridden by any</span>
        <span class="comment">// extensions specified in Attributes.</span>
        <span class="comment">//</span>
        <span class="comment">// The ExtraExtensions field is not populated when parsing CSRs, see</span>
        <span class="comment">// Extensions.</span>
        ExtraExtensions []<a href="/pkg/crypto/x509/pkix/">pkix</a>.<a href="/pkg/crypto/x509/pkix/#Extension">Extension</a>

        <span class="comment">// Subject Alternate Name values.</span>
<span id="CertificateRequest.DNSNames"></span>        DNSNames       []<a href="/pkg/builtin/#string">string</a>
<span id="CertificateRequest.EmailAddresses"></span>        EmailAddresses []<a href="/pkg/builtin/#string">string</a>
<span id="CertificateRequest.IPAddresses"></span>        IPAddresses    []<a href="/pkg/net/">net</a>.<a href="/pkg/net/#IP">IP</a>
<span id="CertificateRequest.URIs"></span>        URIs           []*<a href="/pkg/net/url/">url</a>.<a href="/pkg/net/url/#URL">URL</a>
}</pre>

			

			

			
			
			

			
				
				<h3 id="ParseCertificateRequest">func <a href="/src/crypto/x509/x509.go?s=79738:79812#L2515">ParseCertificateRequest</a>
					<a class="permalink" href="#ParseCertificateRequest">&#xb6;</a>
				</h3>
				<pre>func ParseCertificateRequest(asn1Data []<a href="/pkg/builtin/#byte">byte</a>) (*<a href="#CertificateRequest">CertificateRequest</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ParseCertificateRequest parses a single certificate request from the
given ASN.1 DER data.
</p>

				
				
			

			
				
				<h3 id="CertificateRequest.CheckSignature">func (*CertificateRequest) <a href="/src/crypto/x509/x509.go?s=81509:81560#L2576">CheckSignature</a>
					<a class="permalink" href="#CertificateRequest.CheckSignature">&#xb6;</a>
				</h3>
				<pre>func (c *<a href="#CertificateRequest">CertificateRequest</a>) CheckSignature() <a href="/pkg/builtin/#error">error</a></pre>
				<p>
CheckSignature reports whether the signature on c is valid.
</p>

				
				
				
			
		
			
			
			<h2 id="ConstraintViolationError">type <a href="/src/crypto/x509/x509.go?s=25191:25229#L738">ConstraintViolationError</a>
				<a class="permalink" href="#ConstraintViolationError">&#xb6;</a>
			</h2>
			<p>
ConstraintViolationError results when a requested usage is not permitted by
a certificate. For example: checking a signature when the public key isn&#39;t a
certificate signing key.
</p>

			<pre>type ConstraintViolationError struct{}</pre>

			

			

			
			
			

			

			
				
				<h3 id="ConstraintViolationError.Error">func (ConstraintViolationError) <a href="/src/crypto/x509/x509.go?s=25231:25277#L740">Error</a>
					<a class="permalink" href="#ConstraintViolationError.Error">&#xb6;</a>
				</h3>
				<pre>func (<a href="#ConstraintViolationError">ConstraintViolationError</a>) Error() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="ExtKeyUsage">type <a href="/src/crypto/x509/x509.go?s=18550:18570#L564">ExtKeyUsage</a>
				<a class="permalink" href="#ExtKeyUsage">&#xb6;</a>
			</h2>
			<p>
ExtKeyUsage represents an extended set of actions that are valid for a given key.
Each of the ExtKeyUsage* constants define a unique action.
</p>

			<pre>type ExtKeyUsage <a href="/pkg/builtin/#int">int</a></pre>

			
				
				<pre>const (
        <span id="ExtKeyUsageAny">ExtKeyUsageAny</span> <a href="#ExtKeyUsage">ExtKeyUsage</a> = <a href="/pkg/builtin/#iota">iota</a>
        <span id="ExtKeyUsageServerAuth">ExtKeyUsageServerAuth</span>
        <span id="ExtKeyUsageClientAuth">ExtKeyUsageClientAuth</span>
        <span id="ExtKeyUsageCodeSigning">ExtKeyUsageCodeSigning</span>
        <span id="ExtKeyUsageEmailProtection">ExtKeyUsageEmailProtection</span>
        <span id="ExtKeyUsageIPSECEndSystem">ExtKeyUsageIPSECEndSystem</span>
        <span id="ExtKeyUsageIPSECTunnel">ExtKeyUsageIPSECTunnel</span>
        <span id="ExtKeyUsageIPSECUser">ExtKeyUsageIPSECUser</span>
        <span id="ExtKeyUsageTimeStamping">ExtKeyUsageTimeStamping</span>
        <span id="ExtKeyUsageOCSPSigning">ExtKeyUsageOCSPSigning</span>
        <span id="ExtKeyUsageMicrosoftServerGatedCrypto">ExtKeyUsageMicrosoftServerGatedCrypto</span>
        <span id="ExtKeyUsageNetscapeServerGatedCrypto">ExtKeyUsageNetscapeServerGatedCrypto</span>
        <span id="ExtKeyUsageMicrosoftCommercialCodeSigning">ExtKeyUsageMicrosoftCommercialCodeSigning</span>
        <span id="ExtKeyUsageMicrosoftKernelCodeSigning">ExtKeyUsageMicrosoftKernelCodeSigning</span>
)</pre>
			

			

			
			
			

			

			
		
			
			
			<h2 id="HostnameError">type <a href="/src/crypto/x509/verify.go?s=3581:3656#L88">HostnameError</a>
				<a class="permalink" href="#HostnameError">&#xb6;</a>
			</h2>
			<p>
HostnameError results when the set of authorized names doesn&#39;t match the
requested name.
</p>

			<pre>type HostnameError struct {
<span id="HostnameError.Certificate"></span>        Certificate *<a href="#Certificate">Certificate</a>
<span id="HostnameError.Host"></span>        Host        <a href="/pkg/builtin/#string">string</a>
}</pre>

			

			

			
			
			

			

			
				
				<h3 id="HostnameError.Error">func (HostnameError) <a href="/src/crypto/x509/verify.go?s=3658:3695#L93">Error</a>
					<a class="permalink" href="#HostnameError.Error">&#xb6;</a>
				</h3>
				<pre>func (h <a href="#HostnameError">HostnameError</a>) Error() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="InsecureAlgorithmError">type <a href="/src/crypto/x509/x509.go?s=24805:24851#L729">InsecureAlgorithmError</a>
				<a class="permalink" href="#InsecureAlgorithmError">&#xb6;</a>
			</h2>
			<p>
An InsecureAlgorithmError
</p>

			<pre>type InsecureAlgorithmError <a href="#SignatureAlgorithm">SignatureAlgorithm</a></pre>

			

			

			
			
			

			

			
				
				<h3 id="InsecureAlgorithmError.Error">func (InsecureAlgorithmError) <a href="/src/crypto/x509/x509.go?s=24853:24899#L731">Error</a>
					<a class="permalink" href="#InsecureAlgorithmError.Error">&#xb6;</a>
				</h3>
				<pre>func (e <a href="#InsecureAlgorithmError">InsecureAlgorithmError</a>) Error() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="InvalidReason">type <a href="/src/crypto/x509/verify.go?s=315:337#L12">InvalidReason</a>
				<a class="permalink" href="#InvalidReason">&#xb6;</a>
			</h2>
			
			<pre>type InvalidReason <a href="/pkg/builtin/#int">int</a></pre>

			
				
				<pre>const (
        <span class="comment">// NotAuthorizedToSign results when a certificate is signed by another</span>
        <span class="comment">// which isn&#39;t marked as a CA certificate.</span>
        <span id="NotAuthorizedToSign">NotAuthorizedToSign</span> <a href="#InvalidReason">InvalidReason</a> = <a href="/pkg/builtin/#iota">iota</a>
        <span class="comment">// Expired results when a certificate has expired, based on the time</span>
        <span class="comment">// given in the VerifyOptions.</span>
        <span id="Expired">Expired</span>
        <span class="comment">// CANotAuthorizedForThisName results when an intermediate or root</span>
        <span class="comment">// certificate has a name constraint which doesn&#39;t permit a DNS or</span>
        <span class="comment">// other name (including IP address) in the leaf certificate.</span>
        <span id="CANotAuthorizedForThisName">CANotAuthorizedForThisName</span>
        <span class="comment">// TooManyIntermediates results when a path length constraint is</span>
        <span class="comment">// violated.</span>
        <span id="TooManyIntermediates">TooManyIntermediates</span>
        <span class="comment">// IncompatibleUsage results when the certificate&#39;s key usage indicates</span>
        <span class="comment">// that it may only be used for a different purpose.</span>
        <span id="IncompatibleUsage">IncompatibleUsage</span>
        <span class="comment">// NameMismatch results when the subject name of a parent certificate</span>
        <span class="comment">// does not match the issuer name in the child.</span>
        <span id="NameMismatch">NameMismatch</span>
        <span class="comment">// NameConstraintsWithoutSANs results when a leaf certificate doesn&#39;t</span>
        <span class="comment">// contain a Subject Alternative Name extension, but a CA certificate</span>
        <span class="comment">// contains name constraints.</span>
        <span id="NameConstraintsWithoutSANs">NameConstraintsWithoutSANs</span>
        <span class="comment">// UnconstrainedName results when a CA certificate contains permitted</span>
        <span class="comment">// name constraints, but leaf certificate contains a name of an</span>
        <span class="comment">// unsupported or unconstrained type.</span>
        <span id="UnconstrainedName">UnconstrainedName</span>
        <span class="comment">// TooManyConstraints results when the number of comparision operations</span>
        <span class="comment">// needed to check a certificate exceeds the limit set by</span>
        <span class="comment">// VerifyOptions.MaxConstraintComparisions. This limit exists to</span>
        <span class="comment">// prevent pathological certificates can consuming excessive amounts of</span>
        <span class="comment">// CPU time to verify.</span>
        <span id="TooManyConstraints">TooManyConstraints</span>
        <span class="comment">// CANotAuthorizedForExtKeyUsage results when an intermediate or root</span>
        <span class="comment">// certificate does not permit an extended key usage that is claimed by</span>
        <span class="comment">// the leaf certificate.</span>
        <span id="CANotAuthorizedForExtKeyUsage">CANotAuthorizedForExtKeyUsage</span>
)</pre>
			

			

			
			
			

			

			
		
			
			
			<h2 id="KeyUsage">type <a href="/src/crypto/x509/x509.go?s=16209:16226#L519">KeyUsage</a>
				<a class="permalink" href="#KeyUsage">&#xb6;</a>
			</h2>
			<p>
KeyUsage represents the set of actions that are valid for a given key. It&#39;s
a bitmap of the KeyUsage* constants.
</p>

			<pre>type KeyUsage <a href="/pkg/builtin/#int">int</a></pre>

			
				
				<pre>const (
        <span id="KeyUsageDigitalSignature">KeyUsageDigitalSignature</span> <a href="#KeyUsage">KeyUsage</a> = 1 &lt;&lt; <a href="/pkg/builtin/#iota">iota</a>
        <span id="KeyUsageContentCommitment">KeyUsageContentCommitment</span>
        <span id="KeyUsageKeyEncipherment">KeyUsageKeyEncipherment</span>
        <span id="KeyUsageDataEncipherment">KeyUsageDataEncipherment</span>
        <span id="KeyUsageKeyAgreement">KeyUsageKeyAgreement</span>
        <span id="KeyUsageCertSign">KeyUsageCertSign</span>
        <span id="KeyUsageCRLSign">KeyUsageCRLSign</span>
        <span id="KeyUsageEncipherOnly">KeyUsageEncipherOnly</span>
        <span id="KeyUsageDecipherOnly">KeyUsageDecipherOnly</span>
)</pre>
			

			

			
			
			

			

			
		
			
			
			<h2 id="PEMCipher">type <a href="/src/crypto/x509/pem_decrypt.go?s=472:490#L13">PEMCipher</a>
				<a class="permalink" href="#PEMCipher">&#xb6;</a>
			</h2>
			
			<pre>type PEMCipher <a href="/pkg/builtin/#int">int</a></pre>

			
				<p>
Possible values for the EncryptPEMBlock encryption algorithm.
</p>

				<pre>const (
        <span id="PEMCipherDES">PEMCipherDES</span> <a href="#PEMCipher">PEMCipher</a>
        <span id="PEMCipher3DES">PEMCipher3DES</span>
        <span id="PEMCipherAES128">PEMCipherAES128</span>
        <span id="PEMCipherAES192">PEMCipherAES192</span>
        <span id="PEMCipherAES256">PEMCipherAES256</span>
)</pre>
			

			

			
			
			

			

			
		
			
			
			<h2 id="PublicKeyAlgorithm">type <a href="/src/crypto/x509/x509.go?s=5390:5417#L202">PublicKeyAlgorithm</a>
				<a class="permalink" href="#PublicKeyAlgorithm">&#xb6;</a>
			</h2>
			
			<pre>type PublicKeyAlgorithm <a href="/pkg/builtin/#int">int</a></pre>

			
				
				<pre>const (
        <span id="UnknownPublicKeyAlgorithm">UnknownPublicKeyAlgorithm</span> <a href="#PublicKeyAlgorithm">PublicKeyAlgorithm</a> = <a href="/pkg/builtin/#iota">iota</a>
        <span id="RSA">RSA</span>
        <span id="DSA">DSA</span>
        <span id="ECDSA">ECDSA</span>
)</pre>
			

			

			
			
			

			

			
				
				<h3 id="PublicKeyAlgorithm.String">func (PublicKeyAlgorithm) <a href="/src/crypto/x509/x509.go?s=5587:5633#L217">String</a>
					<a class="permalink" href="#PublicKeyAlgorithm.String">&#xb6;</a>
				</h3>
				<pre>func (algo <a href="#PublicKeyAlgorithm">PublicKeyAlgorithm</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="SignatureAlgorithm">type <a href="/src/crypto/x509/x509.go?s=4703:4730#L163">SignatureAlgorithm</a>
				<a class="permalink" href="#SignatureAlgorithm">&#xb6;</a>
			</h2>
			
			<pre>type SignatureAlgorithm <a href="/pkg/builtin/#int">int</a></pre>

			
				
				<pre>const (
        <span id="UnknownSignatureAlgorithm">UnknownSignatureAlgorithm</span> <a href="#SignatureAlgorithm">SignatureAlgorithm</a> = <a href="/pkg/builtin/#iota">iota</a>
        <span id="MD2WithRSA">MD2WithRSA</span>
        <span id="MD5WithRSA">MD5WithRSA</span>
        <span id="SHA1WithRSA">SHA1WithRSA</span>
        <span id="SHA256WithRSA">SHA256WithRSA</span>
        <span id="SHA384WithRSA">SHA384WithRSA</span>
        <span id="SHA512WithRSA">SHA512WithRSA</span>
        <span id="DSAWithSHA1">DSAWithSHA1</span>
        <span id="DSAWithSHA256">DSAWithSHA256</span>
        <span id="ECDSAWithSHA1">ECDSAWithSHA1</span>
        <span id="ECDSAWithSHA256">ECDSAWithSHA256</span>
        <span id="ECDSAWithSHA384">ECDSAWithSHA384</span>
        <span id="ECDSAWithSHA512">ECDSAWithSHA512</span>
        <span id="SHA256WithRSAPSS">SHA256WithRSAPSS</span>
        <span id="SHA384WithRSAPSS">SHA384WithRSAPSS</span>
        <span id="SHA512WithRSAPSS">SHA512WithRSAPSS</span>
)</pre>
			

			

			
			
			

			

			
				
				<h3 id="SignatureAlgorithm.String">func (SignatureAlgorithm) <a href="/src/crypto/x509/x509.go?s=5195:5241#L193">String</a>
					<a class="permalink" href="#SignatureAlgorithm.String">&#xb6;</a>
				</h3>
				<pre>func (algo <a href="#SignatureAlgorithm">SignatureAlgorithm</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="SystemRootsError">type <a href="/src/crypto/x509/verify.go?s=5352:5395#L150">SystemRootsError</a>
				<a class="permalink" href="#SystemRootsError">&#xb6;</a>
			</h2>
			<p>
SystemRootsError results when we fail to load the system root certificates.
</p>

			<pre>type SystemRootsError struct {
<span id="SystemRootsError.Err"></span>        Err <a href="/pkg/builtin/#error">error</a>
}</pre>

			

			

			
			
			

			

			
				
				<h3 id="SystemRootsError.Error">func (SystemRootsError) <a href="/src/crypto/x509/verify.go?s=5397:5438#L154">Error</a>
					<a class="permalink" href="#SystemRootsError.Error">&#xb6;</a>
				</h3>
				<pre>func (se <a href="#SystemRootsError">SystemRootsError</a>) Error() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="UnhandledCriticalExtension">type <a href="/src/crypto/x509/x509.go?s=32441:32481#L941">UnhandledCriticalExtension</a>
				<a class="permalink" href="#UnhandledCriticalExtension">&#xb6;</a>
			</h2>
			
			<pre>type UnhandledCriticalExtension struct{}</pre>

			

			

			
			
			

			

			
				
				<h3 id="UnhandledCriticalExtension.Error">func (UnhandledCriticalExtension) <a href="/src/crypto/x509/x509.go?s=32483:32533#L943">Error</a>
					<a class="permalink" href="#UnhandledCriticalExtension.Error">&#xb6;</a>
				</h3>
				<pre>func (h <a href="#UnhandledCriticalExtension">UnhandledCriticalExtension</a>) Error() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="UnknownAuthorityError">type <a href="/src/crypto/x509/verify.go?s=4449:4753#L123">UnknownAuthorityError</a>
				<a class="permalink" href="#UnknownAuthorityError">&#xb6;</a>
			</h2>
			<p>
UnknownAuthorityError results when the certificate issuer is unknown
</p>

			<pre>type UnknownAuthorityError struct {
<span id="UnknownAuthorityError.Cert"></span>        Cert *<a href="#Certificate">Certificate</a>
        <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			

			
				
				<h3 id="UnknownAuthorityError.Error">func (UnknownAuthorityError) <a href="/src/crypto/x509/verify.go?s=4755:4800#L133">Error</a>
					<a class="permalink" href="#UnknownAuthorityError.Error">&#xb6;</a>
				</h3>
				<pre>func (e <a href="#UnknownAuthorityError">UnknownAuthorityError</a>) Error() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="VerifyOptions">type <a href="/src/crypto/x509/verify.go?s=5964:6934#L168">VerifyOptions</a>
				<a class="permalink" href="#VerifyOptions">&#xb6;</a>
			</h2>
			<p>
VerifyOptions contains parameters for Certificate.Verify. It&#39;s a structure
because other PKIX verification APIs have ended up needing many options.
</p>

			<pre>type VerifyOptions struct {
<span id="VerifyOptions.DNSName"></span>        DNSName       <a href="/pkg/builtin/#string">string</a>
<span id="VerifyOptions.Intermediates"></span>        Intermediates *<a href="#CertPool">CertPool</a>
<span id="VerifyOptions.Roots"></span>        Roots         *<a href="#CertPool">CertPool</a> <span class="comment">// if nil, the system roots are used</span>
<span id="VerifyOptions.CurrentTime"></span>        CurrentTime   <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a> <span class="comment">// if zero, the current time is used</span>
        <span class="comment">// KeyUsage specifies which Extended Key Usage values are acceptable. A leaf</span>
        <span class="comment">// certificate is accepted if it contains any of the listed values. An empty</span>
        <span class="comment">// list means ExtKeyUsageServerAuth. To accept any key usage, include</span>
        <span class="comment">// ExtKeyUsageAny.</span>
        <span class="comment">//</span>
        <span class="comment">// Certificate chains are required to nest extended key usage values,</span>
        <span class="comment">// irrespective of this value. This matches the Windows CryptoAPI behavior,</span>
        <span class="comment">// but not the spec.</span>
<span id="VerifyOptions.KeyUsages"></span>        KeyUsages []<a href="#ExtKeyUsage">ExtKeyUsage</a>
<span id="VerifyOptions.MaxConstraintComparisions"></span>        <span class="comment">// MaxConstraintComparisions is the maximum number of comparisons to</span>
        <span class="comment">// perform when checking a given certificate&#39;s name constraints. If</span>
        <span class="comment">// zero, a sensible default is used. This limit prevents pathalogical</span>
        <span class="comment">// certificates from consuming excessive amounts of CPU time when</span>
        <span class="comment">// validating.</span>
        MaxConstraintComparisions <a href="/pkg/builtin/#int">int</a>
}</pre>

			

			

			
			
			

			

			
		
	

	





	
	
		<h2 id="pkg-subdirectories">Subdirectories</h2>
	
	


	<div class="pkg-dir">
		<table>
			<tr>
				<th class="pkg-name">Name</th>
				<th class="pkg-synopsis">Synopsis</th>
			</tr>

			
			<tr>
				<td colspan="2"><a href="..">..</a></td>
			</tr>
			

			
				
					<tr>
						<td class="pkg-name" style="padding-left: 0px;">
							<a href="pkix/">pkix</a>
						</td>
						<td class="pkg-synopsis">
							Package pkix contains shared, low level structures used for ASN.1 parsing and serialization of X.509 certificates, CRL and OCSP.
						</td>
					</tr>
				
			
		</table>
	</div>


	



<div id="footer">
Build version go1.10.1.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="/doc/tos.html">Terms of Service</a> |
<a href="http://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
<script type="text/javascript">
(function() {
  var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
  ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
  var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
</html>

