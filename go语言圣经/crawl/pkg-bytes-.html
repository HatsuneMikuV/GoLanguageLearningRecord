<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>bytes - The Go Programming Language</title>

<link type="text/css" rel="stylesheet" href="/lib/godoc/style.css">

<link rel="search" type="application/opensearchdescription+xml" title="godoc" href="/opensearch.xml" />

<link rel="stylesheet" href="/lib/godoc/jquery.treeview.css">
<script>window.initFuncs = [];</script>
<script src="/lib/godoc/jquery.js" defer></script>
<script src="/lib/godoc/jquery.treeview.js" defer></script>
<script src="/lib/godoc/jquery.treeview.edit.js" defer></script>


<script src="/lib/godoc/playground.js" defer></script>

<script>var goVersion = "go1.10.1";</script>
<script src="/lib/godoc/godocs.js" defer></script>
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(["_setAccount", "UA-11222381-2"]);
_gaq.push(["b._setAccount", "UA-49880327-6"]);
window.trackPageview = function() {
  _gaq.push(["_trackPageview", location.pathname+location.hash]);
  _gaq.push(["b._trackPageview", location.pathname+location.hash]);
};
window.trackPageview();
window.trackEvent = function(category, action, opt_label, opt_value, opt_noninteraction) {
  _gaq.push(["_trackEvent", category, action, opt_label, opt_value, opt_noninteraction]);
  _gaq.push(["b._trackEvent", category, action, opt_label, opt_value, opt_noninteraction]);
};
</script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="/">The Go Programming Language</a></div>
<div class="top-heading" id="heading-narrow"><a href="/">Go</a></div>
<a href="#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="/search">
<div id="menu">
<a href="/doc/">Documents</a>
<a href="/pkg/">Packages</a>
<a href="/project/">The Project</a>
<a href="/help/">Help</a>


<a id="playgroundButton" href="http://play.golang.org/" title="Show Go Playground">Play</a>

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>


<div id="playground" class="play">
	<div class="input"><textarea class="code" spellcheck="false">package main

import "fmt"

func main() {
	fmt.Println("Hello, 世界")
}</textarea></div>
	<div class="output"></div>
	<div class="buttons">
		<a class="run" title="Run this code [shift-enter]">Run</a>
		<a class="fmt" title="Format this code">Format</a>
		
	</div>
</div>


<div id="page" class="wide">
<div class="container">


  <h1>
    Package bytes
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script type='text/javascript'>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "bytes"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
Package bytes implements functions for the manipulation of byte slices.
It is analogous to the facilities of the strings package.
</p>

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="#pkg-constants">Constants</a></dd>
			
			
				<dd><a href="#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="#Compare">func Compare(a, b []byte) int</a></dd>
			
				
				<dd><a href="#Contains">func Contains(b, subslice []byte) bool</a></dd>
			
				
				<dd><a href="#ContainsAny">func ContainsAny(b []byte, chars string) bool</a></dd>
			
				
				<dd><a href="#ContainsRune">func ContainsRune(b []byte, r rune) bool</a></dd>
			
				
				<dd><a href="#Count">func Count(s, sep []byte) int</a></dd>
			
				
				<dd><a href="#Equal">func Equal(a, b []byte) bool</a></dd>
			
				
				<dd><a href="#EqualFold">func EqualFold(s, t []byte) bool</a></dd>
			
				
				<dd><a href="#Fields">func Fields(s []byte) [][]byte</a></dd>
			
				
				<dd><a href="#FieldsFunc">func FieldsFunc(s []byte, f func(rune) bool) [][]byte</a></dd>
			
				
				<dd><a href="#HasPrefix">func HasPrefix(s, prefix []byte) bool</a></dd>
			
				
				<dd><a href="#HasSuffix">func HasSuffix(s, suffix []byte) bool</a></dd>
			
				
				<dd><a href="#Index">func Index(s, sep []byte) int</a></dd>
			
				
				<dd><a href="#IndexAny">func IndexAny(s []byte, chars string) int</a></dd>
			
				
				<dd><a href="#IndexByte">func IndexByte(s []byte, c byte) int</a></dd>
			
				
				<dd><a href="#IndexFunc">func IndexFunc(s []byte, f func(r rune) bool) int</a></dd>
			
				
				<dd><a href="#IndexRune">func IndexRune(s []byte, r rune) int</a></dd>
			
				
				<dd><a href="#Join">func Join(s [][]byte, sep []byte) []byte</a></dd>
			
				
				<dd><a href="#LastIndex">func LastIndex(s, sep []byte) int</a></dd>
			
				
				<dd><a href="#LastIndexAny">func LastIndexAny(s []byte, chars string) int</a></dd>
			
				
				<dd><a href="#LastIndexByte">func LastIndexByte(s []byte, c byte) int</a></dd>
			
				
				<dd><a href="#LastIndexFunc">func LastIndexFunc(s []byte, f func(r rune) bool) int</a></dd>
			
				
				<dd><a href="#Map">func Map(mapping func(r rune) rune, s []byte) []byte</a></dd>
			
				
				<dd><a href="#Repeat">func Repeat(b []byte, count int) []byte</a></dd>
			
				
				<dd><a href="#Replace">func Replace(s, old, new []byte, n int) []byte</a></dd>
			
				
				<dd><a href="#Runes">func Runes(s []byte) []rune</a></dd>
			
				
				<dd><a href="#Split">func Split(s, sep []byte) [][]byte</a></dd>
			
				
				<dd><a href="#SplitAfter">func SplitAfter(s, sep []byte) [][]byte</a></dd>
			
				
				<dd><a href="#SplitAfterN">func SplitAfterN(s, sep []byte, n int) [][]byte</a></dd>
			
				
				<dd><a href="#SplitN">func SplitN(s, sep []byte, n int) [][]byte</a></dd>
			
				
				<dd><a href="#Title">func Title(s []byte) []byte</a></dd>
			
				
				<dd><a href="#ToLower">func ToLower(s []byte) []byte</a></dd>
			
				
				<dd><a href="#ToLowerSpecial">func ToLowerSpecial(c unicode.SpecialCase, s []byte) []byte</a></dd>
			
				
				<dd><a href="#ToTitle">func ToTitle(s []byte) []byte</a></dd>
			
				
				<dd><a href="#ToTitleSpecial">func ToTitleSpecial(c unicode.SpecialCase, s []byte) []byte</a></dd>
			
				
				<dd><a href="#ToUpper">func ToUpper(s []byte) []byte</a></dd>
			
				
				<dd><a href="#ToUpperSpecial">func ToUpperSpecial(c unicode.SpecialCase, s []byte) []byte</a></dd>
			
				
				<dd><a href="#Trim">func Trim(s []byte, cutset string) []byte</a></dd>
			
				
				<dd><a href="#TrimFunc">func TrimFunc(s []byte, f func(r rune) bool) []byte</a></dd>
			
				
				<dd><a href="#TrimLeft">func TrimLeft(s []byte, cutset string) []byte</a></dd>
			
				
				<dd><a href="#TrimLeftFunc">func TrimLeftFunc(s []byte, f func(r rune) bool) []byte</a></dd>
			
				
				<dd><a href="#TrimPrefix">func TrimPrefix(s, prefix []byte) []byte</a></dd>
			
				
				<dd><a href="#TrimRight">func TrimRight(s []byte, cutset string) []byte</a></dd>
			
				
				<dd><a href="#TrimRightFunc">func TrimRightFunc(s []byte, f func(r rune) bool) []byte</a></dd>
			
				
				<dd><a href="#TrimSpace">func TrimSpace(s []byte) []byte</a></dd>
			
				
				<dd><a href="#TrimSuffix">func TrimSuffix(s, suffix []byte) []byte</a></dd>
			
			
				
				<dd><a href="#Buffer">type Buffer</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewBuffer">func NewBuffer(buf []byte) *Buffer</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewBufferString">func NewBufferString(s string) *Buffer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.Bytes">func (b *Buffer) Bytes() []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.Cap">func (b *Buffer) Cap() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.Grow">func (b *Buffer) Grow(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.Len">func (b *Buffer) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.Next">func (b *Buffer) Next(n int) []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.Read">func (b *Buffer) Read(p []byte) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.ReadByte">func (b *Buffer) ReadByte() (byte, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.ReadBytes">func (b *Buffer) ReadBytes(delim byte) (line []byte, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.ReadFrom">func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.ReadRune">func (b *Buffer) ReadRune() (r rune, size int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.ReadString">func (b *Buffer) ReadString(delim byte) (line string, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.Reset">func (b *Buffer) Reset()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.String">func (b *Buffer) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.Truncate">func (b *Buffer) Truncate(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.UnreadByte">func (b *Buffer) UnreadByte() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.UnreadRune">func (b *Buffer) UnreadRune() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.Write">func (b *Buffer) Write(p []byte) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.WriteByte">func (b *Buffer) WriteByte(c byte) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.WriteRune">func (b *Buffer) WriteRune(r rune) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.WriteString">func (b *Buffer) WriteString(s string) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.WriteTo">func (b *Buffer) WriteTo(w io.Writer) (n int64, err error)</a></dd>
				
			
				
				<dd><a href="#Reader">type Reader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewReader">func NewReader(b []byte) *Reader</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.Len">func (r *Reader) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.Read">func (r *Reader) Read(b []byte) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.ReadAt">func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.ReadByte">func (r *Reader) ReadByte() (byte, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.ReadRune">func (r *Reader) ReadRune() (ch rune, size int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.Reset">func (r *Reader) Reset(b []byte)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.Seek">func (r *Reader) Seek(offset int64, whence int) (int64, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.Size">func (r *Reader) Size() int64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.UnreadByte">func (r *Reader) UnreadByte() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.UnreadRune">func (r *Reader) UnreadRune() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.WriteTo">func (r *Reader) WriteTo(w io.Writer) (n int64, err error)</a></dd>
				
			
			
				
				<dd><a href="#pkg-note-BUG">Bugs</a></dd>
				
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<dl>
			
			<dd><a class="exampleLink" href="#example_Buffer">Buffer</a></dd>
			
			<dd><a class="exampleLink" href="#example_Buffer_Grow">Buffer.Grow</a></dd>
			
			<dd><a class="exampleLink" href="#example_Buffer_reader">Buffer (Reader)</a></dd>
			
			<dd><a class="exampleLink" href="#example_Compare">Compare</a></dd>
			
			<dd><a class="exampleLink" href="#example_Compare_search">Compare (Search)</a></dd>
			
			<dd><a class="exampleLink" href="#example_Contains">Contains</a></dd>
			
			<dd><a class="exampleLink" href="#example_ContainsAny">ContainsAny</a></dd>
			
			<dd><a class="exampleLink" href="#example_ContainsRune">ContainsRune</a></dd>
			
			<dd><a class="exampleLink" href="#example_Count">Count</a></dd>
			
			<dd><a class="exampleLink" href="#example_Equal">Equal</a></dd>
			
			<dd><a class="exampleLink" href="#example_EqualFold">EqualFold</a></dd>
			
			<dd><a class="exampleLink" href="#example_Fields">Fields</a></dd>
			
			<dd><a class="exampleLink" href="#example_FieldsFunc">FieldsFunc</a></dd>
			
			<dd><a class="exampleLink" href="#example_HasPrefix">HasPrefix</a></dd>
			
			<dd><a class="exampleLink" href="#example_HasSuffix">HasSuffix</a></dd>
			
			<dd><a class="exampleLink" href="#example_Index">Index</a></dd>
			
			<dd><a class="exampleLink" href="#example_IndexAny">IndexAny</a></dd>
			
			<dd><a class="exampleLink" href="#example_IndexByte">IndexByte</a></dd>
			
			<dd><a class="exampleLink" href="#example_IndexFunc">IndexFunc</a></dd>
			
			<dd><a class="exampleLink" href="#example_IndexRune">IndexRune</a></dd>
			
			<dd><a class="exampleLink" href="#example_Join">Join</a></dd>
			
			<dd><a class="exampleLink" href="#example_LastIndex">LastIndex</a></dd>
			
			<dd><a class="exampleLink" href="#example_LastIndexAny">LastIndexAny</a></dd>
			
			<dd><a class="exampleLink" href="#example_LastIndexByte">LastIndexByte</a></dd>
			
			<dd><a class="exampleLink" href="#example_LastIndexFunc">LastIndexFunc</a></dd>
			
			<dd><a class="exampleLink" href="#example_Map">Map</a></dd>
			
			<dd><a class="exampleLink" href="#example_Reader_Len">Reader.Len</a></dd>
			
			<dd><a class="exampleLink" href="#example_Repeat">Repeat</a></dd>
			
			<dd><a class="exampleLink" href="#example_Replace">Replace</a></dd>
			
			<dd><a class="exampleLink" href="#example_Runes">Runes</a></dd>
			
			<dd><a class="exampleLink" href="#example_Split">Split</a></dd>
			
			<dd><a class="exampleLink" href="#example_SplitAfter">SplitAfter</a></dd>
			
			<dd><a class="exampleLink" href="#example_SplitAfterN">SplitAfterN</a></dd>
			
			<dd><a class="exampleLink" href="#example_SplitN">SplitN</a></dd>
			
			<dd><a class="exampleLink" href="#example_Title">Title</a></dd>
			
			<dd><a class="exampleLink" href="#example_ToLower">ToLower</a></dd>
			
			<dd><a class="exampleLink" href="#example_ToTitle">ToTitle</a></dd>
			
			<dd><a class="exampleLink" href="#example_ToUpper">ToUpper</a></dd>
			
			<dd><a class="exampleLink" href="#example_Trim">Trim</a></dd>
			
			<dd><a class="exampleLink" href="#example_TrimFunc">TrimFunc</a></dd>
			
			<dd><a class="exampleLink" href="#example_TrimLeft">TrimLeft</a></dd>
			
			<dd><a class="exampleLink" href="#example_TrimLeftFunc">TrimLeftFunc</a></dd>
			
			<dd><a class="exampleLink" href="#example_TrimPrefix">TrimPrefix</a></dd>
			
			<dd><a class="exampleLink" href="#example_TrimRight">TrimRight</a></dd>
			
			<dd><a class="exampleLink" href="#example_TrimRightFunc">TrimRightFunc</a></dd>
			
			<dd><a class="exampleLink" href="#example_TrimSpace">TrimSpace</a></dd>
			
			<dd><a class="exampleLink" href="#example_TrimSuffix">TrimSuffix</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="/src/bytes/buffer.go">buffer.go</a>
			
				<a href="/src/bytes/bytes.go">bytes.go</a>
			
				<a href="/src/bytes/bytes_amd64.go">bytes_amd64.go</a>
			
				<a href="/src/bytes/bytes_decl.go">bytes_decl.go</a>
			
				<a href="/src/bytes/reader.go">reader.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		<div id="pkg-callgraph" class="toggle" style="display: none">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Internal Call Graph section">Internal call graph ▹</h2>
		</div> <!-- .expanded -->
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Internal Call Graph section">Internal call graph ▾</h2>
			<p>
			  In the call graph viewer below, each node
			  is a function belonging to this package
			  and its children are the functions it
			  calls&mdash;perhaps dynamically.
			</p>
			<p>
			  The root nodes are the entry points of the
			  package: functions that may be called from
			  outside the package.
			  There may be non-exported or anonymous
			  functions among them if they are called
			  dynamically from another package.
			</p>
			<p>
			  Click a node to visit that function's source code.
			  From there you can visit its callers by
			  clicking its declaring <code>func</code>
			  token.
			</p>
			<p>
			  Functions may be omitted if they were
			  determined to be unreachable in the
			  particular programs or tests that were
			  analyzed.
			</p>
			<!-- Zero means show all package entry points. -->
			<ul style="margin-left: 0.5in" id="callgraph-0" class="treeview"></ul>
		</div>
		</div> <!-- #pkg-callgraph -->

		
			<h2 id="pkg-constants">Constants</h2>
			
				<p>
MinRead is the minimum slice size passed to a Read call by
Buffer.ReadFrom. As long as the Buffer has at least MinRead bytes beyond
what is required to hold the contents of r, ReadFrom will not grow the
underlying buffer.
</p>

				<pre>const <span id="MinRead">MinRead</span> = 512</pre>
			
		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<p>
ErrTooLarge is passed to panic if memory cannot be allocated to store data in a buffer.
</p>

				<pre>var <span id="ErrTooLarge">ErrTooLarge</span> = <a href="/pkg/errors/">errors</a>.<a href="/pkg/errors/#New">New</a>(&#34;bytes.Buffer: too large&#34;)</pre>
			
		
		
			
			
			<h2 id="Compare">func <a href="/src/bytes/bytes_decl.go?s=784:813#L14">Compare</a>
				<a class="permalink" href="#Compare">&#xb6;</a>
			</h2>
			<pre>func Compare(a, b []<a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>
Compare returns an integer comparing two byte slices lexicographically.
The result will be 0 if a==b, -1 if a &lt; b, and +1 if a &gt; b.
A nil argument is equivalent to an empty slice.
</p>

			<div id="example_Compare" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
)

func main() {
	// Interpret Compare&#39;s result by comparing it to zero.
	var a, b []byte
	if bytes.Compare(a, b) &lt; 0 {
		// a less b
	}
	if bytes.Compare(a, b) &lt;= 0 {
		// a less or equal b
	}
	if bytes.Compare(a, b) &gt; 0 {
		// a greater b
	}
	if bytes.Compare(a, b) &gt;= 0 {
		// a greater or equal b
	}

	// Prefer Equal to Compare for equality comparisons.
	if bytes.Equal(a, b) {
		// a equal b
	}
	if !bytes.Equal(a, b) {
		// a not equal b
	}
}
</textarea></div>
				<div class="output"><pre></pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>
<div id="example_Compare_search" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (Search)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (Search)</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;sort&#34;
)

func main() {
	// Binary search to find a matching byte slice.
	var needle []byte
	var haystack [][]byte // Assume sorted
	i := sort.Search(len(haystack), func(i int) bool {
		// Return haystack[i] &gt;= needle.
		return bytes.Compare(haystack[i], needle) &gt;= 0
	})
	if i &lt; len(haystack) &amp;&amp; bytes.Equal(haystack[i], needle) {
		// Found it!
	}
}
</textarea></div>
				<div class="output"><pre></pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="Contains">func <a href="/src/bytes/bytes.go?s=1298:1336#L57">Contains</a>
				<a class="permalink" href="#Contains">&#xb6;</a>
			</h2>
			<pre>func Contains(b, subslice []<a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>
Contains reports whether subslice is within b.
</p>

			<div id="example_Contains" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	fmt.Println(bytes.Contains([]byte(&#34;seafood&#34;), []byte(&#34;foo&#34;)))
	fmt.Println(bytes.Contains([]byte(&#34;seafood&#34;), []byte(&#34;bar&#34;)))
	fmt.Println(bytes.Contains([]byte(&#34;seafood&#34;), []byte(&#34;&#34;)))
	fmt.Println(bytes.Contains([]byte(&#34;&#34;), []byte(&#34;&#34;)))
}
</textarea></div>
				<div class="output"><pre>true
false
true
true
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="ContainsAny">func <a href="/src/bytes/bytes.go?s=1466:1511#L62">ContainsAny</a>
				<a class="permalink" href="#ContainsAny">&#xb6;</a>
			</h2>
			<pre>func ContainsAny(b []<a href="/pkg/builtin/#byte">byte</a>, chars <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>
ContainsAny reports whether any of the UTF-8-encoded code points in chars are within b.
</p>

			<div id="example_ContainsAny" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	fmt.Println(bytes.ContainsAny([]byte(&#34;I like seafood.&#34;), &#34;fÄo!&#34;))
	fmt.Println(bytes.ContainsAny([]byte(&#34;I like seafood.&#34;), &#34;去是伟大的.&#34;))
	fmt.Println(bytes.ContainsAny([]byte(&#34;I like seafood.&#34;), &#34;&#34;))
	fmt.Println(bytes.ContainsAny([]byte(&#34;&#34;), &#34;&#34;))
}
</textarea></div>
				<div class="output"><pre>true
true
false
false
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="ContainsRune">func <a href="/src/bytes/bytes.go?s=1638:1678#L67">ContainsRune</a>
				<a class="permalink" href="#ContainsRune">&#xb6;</a>
			</h2>
			<pre>func ContainsRune(b []<a href="/pkg/builtin/#byte">byte</a>, r <a href="/pkg/builtin/#rune">rune</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>
ContainsRune reports whether the rune is contained in the UTF-8-encoded byte slice b.
</p>

			<div id="example_ContainsRune" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	fmt.Println(bytes.ContainsRune([]byte(&#34;I like seafood.&#34;), &#39;f&#39;))
	fmt.Println(bytes.ContainsRune([]byte(&#34;I like seafood.&#34;), &#39;ö&#39;))
	fmt.Println(bytes.ContainsRune([]byte(&#34;去是伟大的!&#34;), &#39;大&#39;))
	fmt.Println(bytes.ContainsRune([]byte(&#34;去是伟大的!&#34;), &#39;!&#39;))
	fmt.Println(bytes.ContainsRune([]byte(&#34;&#34;), &#39;@&#39;))
}
</textarea></div>
				<div class="output"><pre>true
false
true
true
false
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="Count">func <a href="/src/bytes/bytes_amd64.go?s=1916:1945#L73">Count</a>
				<a class="permalink" href="#Count">&#xb6;</a>
			</h2>
			<pre>func Count(s, sep []<a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>
Count counts the number of non-overlapping instances of sep in s.
If sep is an empty slice, Count returns 1 + the number of UTF-8-encoded code points in s.
</p>

			<div id="example_Count" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	fmt.Println(bytes.Count([]byte(&#34;cheese&#34;), []byte(&#34;e&#34;)))
	fmt.Println(bytes.Count([]byte(&#34;five&#34;), []byte(&#34;&#34;))) // before &amp; after each rune
}
</textarea></div>
				<div class="output"><pre>3
5
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="Equal">func <a href="/src/bytes/bytes_decl.go?s=522:550#L7">Equal</a>
				<a class="permalink" href="#Equal">&#xb6;</a>
			</h2>
			<pre>func Equal(a, b []<a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>
Equal returns a boolean reporting whether a and b
are the same length and contain the same bytes.
A nil argument is equivalent to an empty slice.
</p>

			<div id="example_Equal" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	fmt.Println(bytes.Equal([]byte(&#34;Go&#34;), []byte(&#34;Go&#34;)))
	fmt.Println(bytes.Equal([]byte(&#34;Go&#34;), []byte(&#34;C++&#34;)))
}
</textarea></div>
				<div class="output"><pre>true
false
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="EqualFold">func <a href="/src/bytes/bytes.go?s=20930:20962#L764">EqualFold</a>
				<a class="permalink" href="#EqualFold">&#xb6;</a>
			</h2>
			<pre>func EqualFold(s, t []<a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>
EqualFold reports whether s and t, interpreted as UTF-8 strings,
are equal under Unicode case-folding.
</p>

			<div id="example_EqualFold" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	fmt.Println(bytes.EqualFold([]byte(&#34;Go&#34;), []byte(&#34;go&#34;)))
}
</textarea></div>
				<div class="output"><pre>true
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="Fields">func <a href="/src/bytes/bytes.go?s=6966:6996#L268">Fields</a>
				<a class="permalink" href="#Fields">&#xb6;</a>
			</h2>
			<pre>func Fields(s []<a href="/pkg/builtin/#byte">byte</a>) [][]<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>
Fields interprets s as a sequence of UTF-8-encoded code points.
It splits the slice s around each instance of one or more consecutive white space
characters, as defined by unicode.IsSpace, returning a slice of subslices of s or an
empty slice if s contains only white space.
</p>

			<div id="example_Fields" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	fmt.Printf(&#34;Fields are: %q&#34;, bytes.Fields([]byte(&#34;  foo bar  baz   &#34;)))
}
</textarea></div>
				<div class="output"><pre>Fields are: [&#34;foo&#34; &#34;bar&#34; &#34;baz&#34;]
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="FieldsFunc">func <a href="/src/bytes/bytes.go?s=8426:8479#L324">FieldsFunc</a>
				<a class="permalink" href="#FieldsFunc">&#xb6;</a>
			</h2>
			<pre>func FieldsFunc(s []<a href="/pkg/builtin/#byte">byte</a>, f func(<a href="/pkg/builtin/#rune">rune</a>) <a href="/pkg/builtin/#bool">bool</a>) [][]<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>
FieldsFunc interprets s as a sequence of UTF-8-encoded code points.
It splits the slice s at each run of code points c satisfying f(c) and
returns a slice of subslices of s. If all code points in s satisfy f(c), or
len(s) == 0, an empty slice is returned.
FieldsFunc makes no guarantees about the order in which it calls f(c).
If f does not return consistent results for a given c, FieldsFunc may crash.
</p>

			<div id="example_FieldsFunc" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
	&#34;unicode&#34;
)

func main() {
	f := func(c rune) bool {
		return !unicode.IsLetter(c) &amp;&amp; !unicode.IsNumber(c)
	}
	fmt.Printf(&#34;Fields are: %q&#34;, bytes.FieldsFunc([]byte(&#34;  foo1;bar2,baz3...&#34;), f))
}
</textarea></div>
				<div class="output"><pre>Fields are: [&#34;foo1&#34; &#34;bar2&#34; &#34;baz3&#34;]
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="HasPrefix">func <a href="/src/bytes/bytes.go?s=9946:9983#L395">HasPrefix</a>
				<a class="permalink" href="#HasPrefix">&#xb6;</a>
			</h2>
			<pre>func HasPrefix(s, prefix []<a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>
HasPrefix tests whether the byte slice s begins with prefix.
</p>

			<div id="example_HasPrefix" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	fmt.Println(bytes.HasPrefix([]byte(&#34;Gopher&#34;), []byte(&#34;Go&#34;)))
	fmt.Println(bytes.HasPrefix([]byte(&#34;Gopher&#34;), []byte(&#34;C&#34;)))
	fmt.Println(bytes.HasPrefix([]byte(&#34;Gopher&#34;), []byte(&#34;&#34;)))
}
</textarea></div>
				<div class="output"><pre>true
false
true
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="HasSuffix">func <a href="/src/bytes/bytes.go?s=10116:10153#L400">HasSuffix</a>
				<a class="permalink" href="#HasSuffix">&#xb6;</a>
			</h2>
			<pre>func HasSuffix(s, suffix []<a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>
HasSuffix tests whether the byte slice s ends with suffix.
</p>

			<div id="example_HasSuffix" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	fmt.Println(bytes.HasSuffix([]byte(&#34;Amigo&#34;), []byte(&#34;go&#34;)))
	fmt.Println(bytes.HasSuffix([]byte(&#34;Amigo&#34;), []byte(&#34;O&#34;)))
	fmt.Println(bytes.HasSuffix([]byte(&#34;Amigo&#34;), []byte(&#34;Ami&#34;)))
	fmt.Println(bytes.HasSuffix([]byte(&#34;Amigo&#34;), []byte(&#34;&#34;)))
}
</textarea></div>
				<div class="output"><pre>true
false
false
true
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="Index">func <a href="/src/bytes/bytes_amd64.go?s=712:741#L17">Index</a>
				<a class="permalink" href="#Index">&#xb6;</a>
			</h2>
			<pre>func Index(s, sep []<a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>
Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.
</p>

			<div id="example_Index" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	fmt.Println(bytes.Index([]byte(&#34;chicken&#34;), []byte(&#34;ken&#34;)))
	fmt.Println(bytes.Index([]byte(&#34;chicken&#34;), []byte(&#34;dmr&#34;)))
}
</textarea></div>
				<div class="output"><pre>4
-1
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="IndexAny">func <a href="/src/bytes/bytes.go?s=3336:3377#L136">IndexAny</a>
				<a class="permalink" href="#IndexAny">&#xb6;</a>
			</h2>
			<pre>func IndexAny(s []<a href="/pkg/builtin/#byte">byte</a>, chars <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>
IndexAny interprets s as a sequence of UTF-8-encoded Unicode code points.
It returns the byte index of the first occurrence in s of any of the Unicode
code points in chars. It returns -1 if chars is empty or if there is no code
point in common.
</p>

			<div id="example_IndexAny" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	fmt.Println(bytes.IndexAny([]byte(&#34;chicken&#34;), &#34;aeiouy&#34;))
	fmt.Println(bytes.IndexAny([]byte(&#34;crwth&#34;), &#34;aeiouy&#34;))
}
</textarea></div>
				<div class="output"><pre>2
-1
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="IndexByte">func <a href="/src/bytes/bytes_decl.go?s=286:322#L1">IndexByte</a>
				<a class="permalink" href="#IndexByte">&#xb6;</a>
			</h2>
			<pre>func IndexByte(s []<a href="/pkg/builtin/#byte">byte</a>, c <a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>
IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s.
</p>

			<div id="example_IndexByte" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	fmt.Println(bytes.IndexByte([]byte(&#34;chicken&#34;), byte(&#39;k&#39;)))
	fmt.Println(bytes.IndexByte([]byte(&#34;chicken&#34;), byte(&#39;g&#39;)))
}
</textarea></div>
				<div class="output"><pre>4
-1
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="IndexFunc">func <a href="/src/bytes/bytes.go?s=16205:16254#L588">IndexFunc</a>
				<a class="permalink" href="#IndexFunc">&#xb6;</a>
			</h2>
			<pre>func IndexFunc(s []<a href="/pkg/builtin/#byte">byte</a>, f func(r <a href="/pkg/builtin/#rune">rune</a>) <a href="/pkg/builtin/#bool">bool</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>
IndexFunc interprets s as a sequence of UTF-8-encoded code points.
It returns the byte index in s of the first Unicode
code point satisfying f(c), or -1 if none do.
</p>

			<div id="example_IndexFunc" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
	&#34;unicode&#34;
)

func main() {
	f := func(c rune) bool {
		return unicode.Is(unicode.Han, c)
	}
	fmt.Println(bytes.IndexFunc([]byte(&#34;Hello, 世界&#34;), f))
	fmt.Println(bytes.IndexFunc([]byte(&#34;Hello, world&#34;), f))
}
</textarea></div>
				<div class="output"><pre>7
-1
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="IndexRune">func <a href="/src/bytes/bytes.go?s=2664:2700#L110">IndexRune</a>
				<a class="permalink" href="#IndexRune">&#xb6;</a>
			</h2>
			<pre>func IndexRune(s []<a href="/pkg/builtin/#byte">byte</a>, r <a href="/pkg/builtin/#rune">rune</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>
IndexRune interprets s as a sequence of UTF-8-encoded code points.
It returns the byte index of the first occurrence in s of the given rune.
It returns -1 if rune is not present in s.
If r is utf8.RuneError, it returns the first instance of any
invalid UTF-8 byte sequence.
</p>

			<div id="example_IndexRune" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	fmt.Println(bytes.IndexRune([]byte(&#34;chicken&#34;), &#39;k&#39;))
	fmt.Println(bytes.IndexRune([]byte(&#34;chicken&#34;), &#39;d&#39;))
}
</textarea></div>
				<div class="output"><pre>4
-1
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="Join">func <a href="/src/bytes/bytes.go?s=9509:9549#L372">Join</a>
				<a class="permalink" href="#Join">&#xb6;</a>
			</h2>
			<pre>func Join(s [][]<a href="/pkg/builtin/#byte">byte</a>, sep []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>
Join concatenates the elements of s to create a new byte slice. The separator
sep is placed between elements in the resulting slice.
</p>

			<div id="example_Join" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	s := [][]byte{[]byte(&#34;foo&#34;), []byte(&#34;bar&#34;), []byte(&#34;baz&#34;)}
	fmt.Printf(&#34;%s&#34;, bytes.Join(s, []byte(&#34;, &#34;)))
}
</textarea></div>
				<div class="output"><pre>foo, bar, baz
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="LastIndex">func <a href="/src/bytes/bytes.go?s=1929:1962#L81">LastIndex</a>
				<a class="permalink" href="#LastIndex">&#xb6;</a>
			</h2>
			<pre>func LastIndex(s, sep []<a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>
LastIndex returns the index of the last instance of sep in s, or -1 if sep is not present in s.
</p>

			<div id="example_LastIndex" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	fmt.Println(bytes.Index([]byte(&#34;go gopher&#34;), []byte(&#34;go&#34;)))
	fmt.Println(bytes.LastIndex([]byte(&#34;go gopher&#34;), []byte(&#34;go&#34;)))
	fmt.Println(bytes.LastIndex([]byte(&#34;go gopher&#34;), []byte(&#34;rodent&#34;)))
}
</textarea></div>
				<div class="output"><pre>0
3
-1
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="LastIndexAny">func <a href="/src/bytes/bytes.go?s=4110:4155#L172">LastIndexAny</a>
				<a class="permalink" href="#LastIndexAny">&#xb6;</a>
			</h2>
			<pre>func LastIndexAny(s []<a href="/pkg/builtin/#byte">byte</a>, chars <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>
LastIndexAny interprets s as a sequence of UTF-8-encoded Unicode code
points. It returns the byte index of the last occurrence in s of any of
the Unicode code points in chars. It returns -1 if chars is empty or if
there is no code point in common.
</p>

			<div id="example_LastIndexAny" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	fmt.Println(bytes.LastIndexAny([]byte(&#34;go gopher&#34;), &#34;MüQp&#34;))
	fmt.Println(bytes.LastIndexAny([]byte(&#34;go 地鼠&#34;), &#34;地大&#34;))
	fmt.Println(bytes.LastIndexAny([]byte(&#34;go gopher&#34;), &#34;z,!.&#34;))
}
</textarea></div>
				<div class="output"><pre>5
3
-1
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="LastIndexByte">func <a href="/src/bytes/bytes.go?s=2246:2286#L96">LastIndexByte</a>
				<a class="permalink" href="#LastIndexByte">&#xb6;</a>
			</h2>
			<pre>func LastIndexByte(s []<a href="/pkg/builtin/#byte">byte</a>, c <a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>
LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.
</p>

			<div id="example_LastIndexByte" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	fmt.Println(bytes.LastIndexByte([]byte(&#34;go gopher&#34;), byte(&#39;g&#39;)))
	fmt.Println(bytes.LastIndexByte([]byte(&#34;go gopher&#34;), byte(&#39;r&#39;)))
	fmt.Println(bytes.LastIndexByte([]byte(&#34;go gopher&#34;), byte(&#39;z&#39;)))
}
</textarea></div>
				<div class="output"><pre>3
8
-1
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="LastIndexFunc">func <a href="/src/bytes/bytes.go?s=16467:16520#L595">LastIndexFunc</a>
				<a class="permalink" href="#LastIndexFunc">&#xb6;</a>
			</h2>
			<pre>func LastIndexFunc(s []<a href="/pkg/builtin/#byte">byte</a>, f func(r <a href="/pkg/builtin/#rune">rune</a>) <a href="/pkg/builtin/#bool">bool</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>
LastIndexFunc interprets s as a sequence of UTF-8-encoded code points.
It returns the byte index in s of the last Unicode
code point satisfying f(c), or -1 if none do.
</p>

			<div id="example_LastIndexFunc" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
	&#34;unicode&#34;
)

func main() {
	fmt.Println(bytes.LastIndexFunc([]byte(&#34;go gopher!&#34;), unicode.IsLetter))
	fmt.Println(bytes.LastIndexFunc([]byte(&#34;go gopher!&#34;), unicode.IsPunct))
	fmt.Println(bytes.LastIndexFunc([]byte(&#34;go gopher!&#34;), unicode.IsNumber))
}
</textarea></div>
				<div class="output"><pre>8
9
-1
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="Map">func <a href="/src/bytes/bytes.go?s=10533:10585#L408">Map</a>
				<a class="permalink" href="#Map">&#xb6;</a>
			</h2>
			<pre>func Map(mapping func(r <a href="/pkg/builtin/#rune">rune</a>) <a href="/pkg/builtin/#rune">rune</a>, s []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>
Map returns a copy of the byte slice s with all its characters modified
according to the mapping function. If mapping returns a negative value, the character is
dropped from the byte slice with no replacement. The characters in s and the
output are interpreted as UTF-8-encoded code points.
</p>

			<div id="example_Map" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	rot13 := func(r rune) rune {
		switch {
		case r &gt;= &#39;A&#39; &amp;&amp; r &lt;= &#39;Z&#39;:
			return &#39;A&#39; + (r-&#39;A&#39;+13)%26
		case r &gt;= &#39;a&#39; &amp;&amp; r &lt;= &#39;z&#39;:
			return &#39;a&#39; + (r-&#39;a&#39;+13)%26
		}
		return r
	}
	fmt.Printf(&#34;%s&#34;, bytes.Map(rot13, []byte(&#34;&#39;Twas brillig and the slithy gopher...&#34;)))
}
</textarea></div>
				<div class="output"><pre>&#39;Gjnf oevyyvt naq gur fyvgul tbcure...
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="Repeat">func <a href="/src/bytes/bytes.go?s=11544:11583#L445">Repeat</a>
				<a class="permalink" href="#Repeat">&#xb6;</a>
			</h2>
			<pre>func Repeat(b []<a href="/pkg/builtin/#byte">byte</a>, count <a href="/pkg/builtin/#int">int</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>
Repeat returns a new byte slice consisting of count copies of b.
</p>
<p>
It panics if count is negative or if
the result of (len(b) * count) overflows.
</p>

			<div id="example_Repeat" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	fmt.Printf(&#34;ba%s&#34;, bytes.Repeat([]byte(&#34;na&#34;), 2))
}
</textarea></div>
				<div class="output"><pre>banana
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="Replace">func <a href="/src/bytes/bytes.go?s=20173:20219#L726">Replace</a>
				<a class="permalink" href="#Replace">&#xb6;</a>
			</h2>
			<pre>func Replace(s, old, new []<a href="/pkg/builtin/#byte">byte</a>, n <a href="/pkg/builtin/#int">int</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>
Replace returns a copy of the slice s with the first n
non-overlapping instances of old replaced by new.
If old is empty, it matches at the beginning of the slice
and after each UTF-8 sequence, yielding up to k+1 replacements
for a k-rune slice.
If n &lt; 0, there is no limit on the number of replacements.
</p>

			<div id="example_Replace" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	fmt.Printf(&#34;%s\n&#34;, bytes.Replace([]byte(&#34;oink oink oink&#34;), []byte(&#34;k&#34;), []byte(&#34;ky&#34;), 2))
	fmt.Printf(&#34;%s\n&#34;, bytes.Replace([]byte(&#34;oink oink oink&#34;), []byte(&#34;oink&#34;), []byte(&#34;moo&#34;), -1))
}
</textarea></div>
				<div class="output"><pre>oinky oinky oink
moo moo moo
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="Runes">func <a href="/src/bytes/bytes.go?s=19682:19709#L708">Runes</a>
				<a class="permalink" href="#Runes">&#xb6;</a>
			</h2>
			<pre>func Runes(s []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#rune">rune</a></pre>
			<p>
Runes interprets s as a sequence of UTF-8-encoded code points.
It returns a slice of runes (Unicode code points) equivalent to s.
</p>

			<div id="example_Runes" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	rs := bytes.Runes([]byte(&#34;go gopher&#34;))
	for _, r := range rs {
		fmt.Printf(&#34;%#U\n&#34;, r)
	}
}
</textarea></div>
				<div class="output"><pre>U+0067 &#39;g&#39;
U+006F &#39;o&#39;
U+0020 &#39; &#39;
U+0067 &#39;g&#39;
U+006F &#39;o&#39;
U+0070 &#39;p&#39;
U+0068 &#39;h&#39;
U+0065 &#39;e&#39;
U+0072 &#39;r&#39;
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="Split">func <a href="/src/bytes/bytes.go?s=6210:6244#L252">Split</a>
				<a class="permalink" href="#Split">&#xb6;</a>
			</h2>
			<pre>func Split(s, sep []<a href="/pkg/builtin/#byte">byte</a>) [][]<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>
Split slices s into all subslices separated by sep and returns a slice of
the subslices between those separators.
If sep is empty, Split splits after each UTF-8 sequence.
It is equivalent to SplitN with a count of -1.
</p>

			<div id="example_Split" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	fmt.Printf(&#34;%q\n&#34;, bytes.Split([]byte(&#34;a,b,c&#34;), []byte(&#34;,&#34;)))
	fmt.Printf(&#34;%q\n&#34;, bytes.Split([]byte(&#34;a man a plan a canal panama&#34;), []byte(&#34;a &#34;)))
	fmt.Printf(&#34;%q\n&#34;, bytes.Split([]byte(&#34; xyz &#34;), []byte(&#34;&#34;)))
	fmt.Printf(&#34;%q\n&#34;, bytes.Split([]byte(&#34;&#34;), []byte(&#34;Bernardo O&#39;Higgins&#34;)))
}
</textarea></div>
				<div class="output"><pre>[&#34;a&#34; &#34;b&#34; &#34;c&#34;]
[&#34;&#34; &#34;man &#34; &#34;plan &#34; &#34;canal panama&#34;]
[&#34; &#34; &#34;x&#34; &#34;y&#34; &#34;z&#34; &#34; &#34;]
[&#34;&#34;]
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="SplitAfter">func <a href="/src/bytes/bytes.go?s=6513:6552#L258">SplitAfter</a>
				<a class="permalink" href="#SplitAfter">&#xb6;</a>
			</h2>
			<pre>func SplitAfter(s, sep []<a href="/pkg/builtin/#byte">byte</a>) [][]<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>
SplitAfter slices s into all subslices after each instance of sep and
returns a slice of those subslices.
If sep is empty, SplitAfter splits after each UTF-8 sequence.
It is equivalent to SplitAfterN with a count of -1.
</p>

			<div id="example_SplitAfter" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	fmt.Printf(&#34;%q\n&#34;, bytes.SplitAfter([]byte(&#34;a,b,c&#34;), []byte(&#34;,&#34;)))
}
</textarea></div>
				<div class="output"><pre>[&#34;a,&#34; &#34;b,&#34; &#34;c&#34;]
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="SplitAfterN">func <a href="/src/bytes/bytes.go?s=5889:5936#L244">SplitAfterN</a>
				<a class="permalink" href="#SplitAfterN">&#xb6;</a>
			</h2>
			<pre>func SplitAfterN(s, sep []<a href="/pkg/builtin/#byte">byte</a>, n <a href="/pkg/builtin/#int">int</a>) [][]<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>
SplitAfterN slices s into subslices after each instance of sep and
returns a slice of those subslices.
If sep is empty, SplitAfterN splits after each UTF-8 sequence.
The count determines the number of subslices to return:
</p>
<pre>n &gt; 0: at most n subslices; the last subslice will be the unsplit remainder.
n == 0: the result is nil (zero subslices)
n &lt; 0: all subslices
</pre>

			<div id="example_SplitAfterN" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	fmt.Printf(&#34;%q\n&#34;, bytes.SplitAfterN([]byte(&#34;a,b,c&#34;), []byte(&#34;,&#34;), 2))
}
</textarea></div>
				<div class="output"><pre>[&#34;a,&#34; &#34;b,c&#34;]
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="SplitN">func <a href="/src/bytes/bytes.go?s=5421:5463#L235">SplitN</a>
				<a class="permalink" href="#SplitN">&#xb6;</a>
			</h2>
			<pre>func SplitN(s, sep []<a href="/pkg/builtin/#byte">byte</a>, n <a href="/pkg/builtin/#int">int</a>) [][]<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>
SplitN slices s into subslices separated by sep and returns a slice of
the subslices between those separators.
If sep is empty, SplitN splits after each UTF-8 sequence.
The count determines the number of subslices to return:
</p>
<pre>n &gt; 0: at most n subslices; the last subslice will be the unsplit remainder.
n == 0: the result is nil (zero subslices)
n &lt; 0: all subslices
</pre>

			<div id="example_SplitN" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	fmt.Printf(&#34;%q\n&#34;, bytes.SplitN([]byte(&#34;a,b,c&#34;), []byte(&#34;,&#34;), 2))
	z := bytes.SplitN([]byte(&#34;a,b,c&#34;), []byte(&#34;,&#34;), 0)
	fmt.Printf(&#34;%q (nil = %v)\n&#34;, z, z == nil)
}
</textarea></div>
				<div class="output"><pre>[&#34;a&#34; &#34;b,c&#34;]
[] (nil = true)
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="Title">func <a href="/src/bytes/bytes.go?s=14366:14393#L521">Title</a>
				<a class="permalink" href="#Title">&#xb6;</a>
			</h2>
			<pre>func Title(s []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>
Title treats s as UTF-8-encoded bytes and returns a copy with all Unicode letters that begin
words mapped to their title case.
</p>
<p>
BUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly.
</p>

			<div id="example_Title" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	fmt.Printf(&#34;%s&#34;, bytes.Title([]byte(&#34;her royal highness&#34;)))
}
</textarea></div>
				<div class="output"><pre>Her Royal Highness
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="ToLower">func <a href="/src/bytes/bytes.go?s=12339:12368#L469">ToLower</a>
				<a class="permalink" href="#ToLower">&#xb6;</a>
			</h2>
			<pre>func ToLower(s []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>
ToLower treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their lower case.
</p>

			<div id="example_ToLower" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	fmt.Printf(&#34;%s&#34;, bytes.ToLower([]byte(&#34;Gopher&#34;)))
}
</textarea></div>
				<div class="output"><pre>gopher
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="ToLowerSpecial">func <a href="/src/bytes/bytes.go?s=13061:13120#L482">ToLowerSpecial</a>
				<a class="permalink" href="#ToLowerSpecial">&#xb6;</a>
			</h2>
			<pre>func ToLowerSpecial(c <a href="/pkg/unicode/">unicode</a>.<a href="/pkg/unicode/#SpecialCase">SpecialCase</a>, s []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>
ToLowerSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their
lower case, giving priority to the special casing rules.
</p>

			
			

		
			
			
			<h2 id="ToTitle">func <a href="/src/bytes/bytes.go?s=12524:12553#L472">ToTitle</a>
				<a class="permalink" href="#ToTitle">&#xb6;</a>
			</h2>
			<pre>func ToTitle(s []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>
ToTitle treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case.
</p>

			<div id="example_ToTitle" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	fmt.Printf(&#34;%s\n&#34;, bytes.ToTitle([]byte(&#34;loud noises&#34;)))
	fmt.Printf(&#34;%s\n&#34;, bytes.ToTitle([]byte(&#34;хлеб&#34;)))
}
</textarea></div>
				<div class="output"><pre>LOUD NOISES
ХЛЕБ
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="ToTitleSpecial">func <a href="/src/bytes/bytes.go?s=13358:13417#L488">ToTitleSpecial</a>
				<a class="permalink" href="#ToTitleSpecial">&#xb6;</a>
			</h2>
			<pre>func ToTitleSpecial(c <a href="/pkg/unicode/">unicode</a>.<a href="/pkg/unicode/#SpecialCase">SpecialCase</a>, s []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>
ToTitleSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their
title case, giving priority to the special casing rules.
</p>

			
			

		
			
			
			<h2 id="ToUpper">func <a href="/src/bytes/bytes.go?s=12154:12183#L466">ToUpper</a>
				<a class="permalink" href="#ToUpper">&#xb6;</a>
			</h2>
			<pre>func ToUpper(s []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>
ToUpper treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters within it mapped to their upper case.
</p>

			<div id="example_ToUpper" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	fmt.Printf(&#34;%s&#34;, bytes.ToUpper([]byte(&#34;Gopher&#34;)))
}
</textarea></div>
				<div class="output"><pre>GOPHER
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="ToUpperSpecial">func <a href="/src/bytes/bytes.go?s=12764:12823#L476">ToUpperSpecial</a>
				<a class="permalink" href="#ToUpperSpecial">&#xb6;</a>
			</h2>
			<pre>func ToUpperSpecial(c <a href="/pkg/unicode/">unicode</a>.<a href="/pkg/unicode/#SpecialCase">SpecialCase</a>, s []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>
ToUpperSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their
upper case, giving priority to the special casing rules.
</p>

			
			

		
			
			
			<h2 id="Trim">func <a href="/src/bytes/bytes.go?s=18828:18869#L684">Trim</a>
				<a class="permalink" href="#Trim">&#xb6;</a>
			</h2>
			<pre>func Trim(s []<a href="/pkg/builtin/#byte">byte</a>, cutset <a href="/pkg/builtin/#string">string</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>
Trim returns a subslice of s by slicing off all leading and
trailing UTF-8-encoded code points contained in cutset.
</p>

			<div id="example_Trim" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	fmt.Printf(&#34;[%q]&#34;, bytes.Trim([]byte(&#34; !!! Achtung! Achtung! !!! &#34;), &#34;! &#34;))
}
</textarea></div>
				<div class="output"><pre>[&#34;Achtung! Achtung&#34;]
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="TrimFunc">func <a href="/src/bytes/bytes.go?s=15445:15496#L563">TrimFunc</a>
				<a class="permalink" href="#TrimFunc">&#xb6;</a>
			</h2>
			<pre>func TrimFunc(s []<a href="/pkg/builtin/#byte">byte</a>, f func(r <a href="/pkg/builtin/#rune">rune</a>) <a href="/pkg/builtin/#bool">bool</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>
TrimFunc returns a subslice of s by slicing off all leading and trailing
UTF-8-encoded code points c that satisfy f(c).
</p>

			<div id="example_TrimFunc" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
	&#34;unicode&#34;
)

func main() {
	fmt.Println(string(bytes.TrimFunc([]byte(&#34;go-gopher!&#34;), unicode.IsLetter)))
	fmt.Println(string(bytes.TrimFunc([]byte(&#34;\&#34;go-gopher!\&#34;&#34;), unicode.IsLetter)))
	fmt.Println(string(bytes.TrimFunc([]byte(&#34;go-gopher!&#34;), unicode.IsPunct)))
	fmt.Println(string(bytes.TrimFunc([]byte(&#34;1234go-gopher!567&#34;), unicode.IsNumber)))
}
</textarea></div>
				<div class="output"><pre>-gopher!
&#34;go-gopher!&#34;
go-gopher
go-gopher!
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="TrimLeft">func <a href="/src/bytes/bytes.go?s=19032:19077#L690">TrimLeft</a>
				<a class="permalink" href="#TrimLeft">&#xb6;</a>
			</h2>
			<pre>func TrimLeft(s []<a href="/pkg/builtin/#byte">byte</a>, cutset <a href="/pkg/builtin/#string">string</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>
TrimLeft returns a subslice of s by slicing off all leading
UTF-8-encoded code points contained in cutset.
</p>

			<div id="example_TrimLeft" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	fmt.Print(string(bytes.TrimLeft([]byte(&#34;453gopher8257&#34;), &#34;0123456789&#34;)))
}
</textarea></div>
				<div class="output"><pre>gopher8257
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="TrimLeftFunc">func <a href="/src/bytes/bytes.go?s=14853:14908#L540">TrimLeftFunc</a>
				<a class="permalink" href="#TrimLeftFunc">&#xb6;</a>
			</h2>
			<pre>func TrimLeftFunc(s []<a href="/pkg/builtin/#byte">byte</a>, f func(r <a href="/pkg/builtin/#rune">rune</a>) <a href="/pkg/builtin/#bool">bool</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>
TrimLeftFunc treats s as UTF-8-encoded bytes and returns a subslice of s by slicing off
all leading UTF-8-encoded code points c that satisfy f(c).
</p>

			<div id="example_TrimLeftFunc" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
	&#34;unicode&#34;
)

func main() {
	fmt.Println(string(bytes.TrimLeftFunc([]byte(&#34;go-gopher&#34;), unicode.IsLetter)))
	fmt.Println(string(bytes.TrimLeftFunc([]byte(&#34;go-gopher!&#34;), unicode.IsPunct)))
	fmt.Println(string(bytes.TrimLeftFunc([]byte(&#34;1234go-gopher!567&#34;), unicode.IsNumber)))
}
</textarea></div>
				<div class="output"><pre>-gopher
go-gopher!
go-gopher!567
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="TrimPrefix">func <a href="/src/bytes/bytes.go?s=15675:15715#L569">TrimPrefix</a>
				<a class="permalink" href="#TrimPrefix">&#xb6;</a>
			</h2>
			<pre>func TrimPrefix(s, prefix []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>
TrimPrefix returns s without the provided leading prefix string.
If s doesn&#39;t start with prefix, s is returned unchanged.
</p>

			<div id="example_TrimPrefix" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	var b = []byte(&#34;Goodbye,, world!&#34;)
	b = bytes.TrimPrefix(b, []byte(&#34;Goodbye,&#34;))
	b = bytes.TrimPrefix(b, []byte(&#34;See ya,&#34;))
	fmt.Printf(&#34;Hello%s&#34;, b)
}
</textarea></div>
				<div class="output"><pre>Hello, world!
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="TrimRight">func <a href="/src/bytes/bytes.go?s=19255:19301#L696">TrimRight</a>
				<a class="permalink" href="#TrimRight">&#xb6;</a>
			</h2>
			<pre>func TrimRight(s []<a href="/pkg/builtin/#byte">byte</a>, cutset <a href="/pkg/builtin/#string">string</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>
TrimRight returns a subslice of s by slicing off all trailing
UTF-8-encoded code points that are contained in cutset.
</p>

			<div id="example_TrimRight" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	fmt.Print(string(bytes.TrimRight([]byte(&#34;453gopher8257&#34;), &#34;0123456789&#34;)))
}
</textarea></div>
				<div class="output"><pre>453gopher
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="TrimRightFunc">func <a href="/src/bytes/bytes.go?s=15106:15162#L550">TrimRightFunc</a>
				<a class="permalink" href="#TrimRightFunc">&#xb6;</a>
			</h2>
			<pre>func TrimRightFunc(s []<a href="/pkg/builtin/#byte">byte</a>, f func(r <a href="/pkg/builtin/#rune">rune</a>) <a href="/pkg/builtin/#bool">bool</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>
TrimRightFunc returns a subslice of s by slicing off all trailing
UTF-8-encoded code points c that satisfy f(c).
</p>

			<div id="example_TrimRightFunc" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
	&#34;unicode&#34;
)

func main() {
	fmt.Println(string(bytes.TrimRightFunc([]byte(&#34;go-gopher&#34;), unicode.IsLetter)))
	fmt.Println(string(bytes.TrimRightFunc([]byte(&#34;go-gopher!&#34;), unicode.IsPunct)))
	fmt.Println(string(bytes.TrimRightFunc([]byte(&#34;1234go-gopher!567&#34;), unicode.IsNumber)))
}
</textarea></div>
				<div class="output"><pre>go-
go-gopher
1234go-gopher!
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="TrimSpace">func <a href="/src/bytes/bytes.go?s=19472:19503#L702">TrimSpace</a>
				<a class="permalink" href="#TrimSpace">&#xb6;</a>
			</h2>
			<pre>func TrimSpace(s []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>
TrimSpace returns a subslice of s by slicing off all leading and
trailing white space, as defined by Unicode.
</p>

			<div id="example_TrimSpace" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	fmt.Printf(&#34;%s&#34;, bytes.TrimSpace([]byte(&#34; \t\n a lone gopher \n\t\r\n&#34;)))
}
</textarea></div>
				<div class="output"><pre>a lone gopher
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
			
			
			<h2 id="TrimSuffix">func <a href="/src/bytes/bytes.go?s=15913:15953#L578">TrimSuffix</a>
				<a class="permalink" href="#TrimSuffix">&#xb6;</a>
			</h2>
			<pre>func TrimSuffix(s, suffix []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>
TrimSuffix returns s without the provided trailing suffix string.
If s doesn&#39;t end with suffix, s is returned unchanged.
</p>

			<div id="example_TrimSuffix" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;os&#34;
)

func main() {
	var b = []byte(&#34;Hello, goodbye, etc!&#34;)
	b = bytes.TrimSuffix(b, []byte(&#34;goodbye, etc!&#34;))
	b = bytes.TrimSuffix(b, []byte(&#34;gopher&#34;))
	b = append(b, bytes.TrimSuffix([]byte(&#34;world!&#34;), []byte(&#34;x!&#34;))...)
	os.Stdout.Write(b)
}
</textarea></div>
				<div class="output"><pre>Hello, world!
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			

		
		
			
			
			<h2 id="Buffer">type <a href="/src/bytes/buffer.go?s=402:817#L7">Buffer</a>
				<a class="permalink" href="#Buffer">&#xb6;</a>
			</h2>
			<p>
A Buffer is a variable-sized buffer of bytes with Read and Write methods.
The zero value for Buffer is an empty buffer ready to use.
</p>

			<pre>type Buffer struct {
        <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			<div id="example_Buffer" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
	&#34;os&#34;
)

func main() {
	var b bytes.Buffer // A Buffer needs no initialization.
	b.Write([]byte(&#34;Hello &#34;))
	fmt.Fprintf(&amp;b, &#34;world!&#34;)
	b.WriteTo(os.Stdout)
}
</textarea></div>
				<div class="output"><pre>Hello world!
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>
<div id="example_Buffer_reader" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (Reader)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (Reader)</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;encoding/base64&#34;
	&#34;io&#34;
	&#34;os&#34;
)

func main() {
	// A Buffer can turn a string or a []byte into an io.Reader.
	buf := bytes.NewBufferString(&#34;R29waGVycyBydWxlIQ==&#34;)
	dec := base64.NewDecoder(base64.StdEncoding, buf)
	io.Copy(os.Stdout, dec)
}
</textarea></div>
				<div class="output"><pre>Gophers rule!
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

			
			

			
				
				<h3 id="NewBuffer">func <a href="/src/bytes/buffer.go?s=14338:14372#L439">NewBuffer</a>
					<a class="permalink" href="#NewBuffer">&#xb6;</a>
				</h3>
				<pre>func NewBuffer(buf []<a href="/pkg/builtin/#byte">byte</a>) *<a href="#Buffer">Buffer</a></pre>
				<p>
NewBuffer creates and initializes a new Buffer using buf as its
initial contents. The new Buffer takes ownership of buf, and the
caller should not use buf after this call. NewBuffer is intended to
prepare a Buffer to read existing data. It can also be used to size
the internal buffer for writing. To do that, buf should have the
desired capacity but a length of zero.
</p>
<p>
In most cases, new(Buffer) (or just declaring a Buffer variable) is
sufficient to initialize a Buffer.
</p>

				
				
			
				
				<h3 id="NewBufferString">func <a href="/src/bytes/buffer.go?s=14680:14718#L447">NewBufferString</a>
					<a class="permalink" href="#NewBufferString">&#xb6;</a>
				</h3>
				<pre>func NewBufferString(s <a href="/pkg/builtin/#string">string</a>) *<a href="#Buffer">Buffer</a></pre>
				<p>
NewBufferString creates and initializes a new Buffer using string s as its
initial contents. It is intended to prepare a buffer to read an existing
string.
</p>
<p>
In most cases, new(Buffer) (or just declaring a Buffer variable) is
sufficient to initialize a Buffer.
</p>

				
				
			

			
				
				<h3 id="Buffer.Bytes">func (*Buffer) <a href="/src/bytes/buffer.go?s=2218:2249#L45">Bytes</a>
					<a class="permalink" href="#Buffer.Bytes">&#xb6;</a>
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) Bytes() []<a href="/pkg/builtin/#byte">byte</a></pre>
				<p>
Bytes returns a slice of length b.Len() holding the unread portion of the buffer.
The slice is valid for use only until the next buffer modification (that is,
only until the next call to a method like Read, Write, Reset, or Truncate).
The slice aliases the buffer content at least until the next buffer modification,
so immediate changes to the slice will affect the result of future reads.
</p>

				
				
				
			
				
				<h3 id="Buffer.Cap">func (*Buffer) <a href="/src/bytes/buffer.go?s=3043:3069#L68">Cap</a>
					<a class="permalink" href="#Buffer.Cap">&#xb6;</a>
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) Cap() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Cap returns the capacity of the buffer&#39;s underlying byte slice, that is, the
total space allocated for the buffer&#39;s data.
</p>

				
				
				
			
				
				<h3 id="Buffer.Grow">func (*Buffer) <a href="/src/bytes/buffer.go?s=5434:5462#L149">Grow</a>
					<a class="permalink" href="#Buffer.Grow">&#xb6;</a>
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) Grow(n <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Grow grows the buffer&#39;s capacity, if necessary, to guarantee space for
another n bytes. After Grow(n), at least n bytes can be written to the
buffer without another allocation.
If n is negative, Grow will panic.
If the buffer can&#39;t grow it will panic with ErrTooLarge.
</p>

				
				<div id="example_Buffer_Grow" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	var b bytes.Buffer
	b.Grow(64)
	bb := b.Bytes()
	b.Write([]byte(&#34;64 bytes or fewer&#34;))
	fmt.Printf(&#34;%q&#34;, bb[:b.Len()])
}
</textarea></div>
				<div class="output"><pre>&#34;64 bytes or fewer&#34;
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

				
			
				
				<h3 id="Buffer.Len">func (*Buffer) <a href="/src/bytes/buffer.go?s=2857:2883#L64">Len</a>
					<a class="permalink" href="#Buffer.Len">&#xb6;</a>
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) Len() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Len returns the number of bytes of the unread portion of the buffer;
b.Len() == len(b.Bytes()).
</p>

				
				
				
			
				
				<h3 id="Buffer.Next">func (*Buffer) <a href="/src/bytes/buffer.go?s=10164:10199#L309">Next</a>
					<a class="permalink" href="#Buffer.Next">&#xb6;</a>
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) Next(n <a href="/pkg/builtin/#int">int</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
				<p>
Next returns a slice containing the next n bytes from the buffer,
advancing the buffer as if the bytes had been returned by Read.
If there are fewer than n bytes in the buffer, Next returns the entire buffer.
The slice is only valid until the next call to a read or write method.
</p>

				
				
				
			
				
				<h3 id="Buffer.Read">func (*Buffer) <a href="/src/bytes/buffer.go?s=9564:9614#L287">Read</a>
					<a class="permalink" href="#Buffer.Read">&#xb6;</a>
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) Read(p []<a href="/pkg/builtin/#byte">byte</a>) (n <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Read reads the next len(p) bytes from the buffer or until the buffer
is drained. The return value n is the number of bytes read. If the
buffer has no data to return, err is io.EOF (unless len(p) is zero);
otherwise it is nil.
</p>

				
				
				
			
				
				<h3 id="Buffer.ReadByte">func (*Buffer) <a href="/src/bytes/buffer.go?s=10474:10515#L325">ReadByte</a>
					<a class="permalink" href="#Buffer.ReadByte">&#xb6;</a>
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) ReadByte() (<a href="/pkg/builtin/#byte">byte</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadByte reads and returns the next byte from the buffer.
If no byte is available, it returns error io.EOF.
</p>

				
				
				
			
				
				<h3 id="Buffer.ReadBytes">func (*Buffer) <a href="/src/bytes/buffer.go?s=12741:12804#L397">ReadBytes</a>
					<a class="permalink" href="#Buffer.ReadBytes">&#xb6;</a>
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) ReadBytes(delim <a href="/pkg/builtin/#byte">byte</a>) (line []<a href="/pkg/builtin/#byte">byte</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadBytes reads until the first occurrence of delim in the input,
returning a slice containing the data up to and including the delimiter.
If ReadBytes encounters an error before finding a delimiter,
it returns the data read before the error and the error itself (often io.EOF).
ReadBytes returns err != nil if and only if the returned data does not end in
delim.
</p>

				
				
				
			
				
				<h3 id="Buffer.ReadFrom">func (*Buffer) <a href="/src/bytes/buffer.go?s=6926:6985#L191">ReadFrom</a>
					<a class="permalink" href="#Buffer.ReadFrom">&#xb6;</a>
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) ReadFrom(r <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Reader">Reader</a>) (n <a href="/pkg/builtin/#int64">int64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadFrom reads data from r until EOF and appends it to the buffer, growing
the buffer as needed. The return value n is the number of bytes read. Any
error except io.EOF encountered during the read is also returned. If the
buffer becomes too large, ReadFrom will panic with ErrTooLarge.
</p>

				
				
				
			
				
				<h3 id="Buffer.ReadRune">func (*Buffer) <a href="/src/bytes/buffer.go?s=10929:10986#L342">ReadRune</a>
					<a class="permalink" href="#Buffer.ReadRune">&#xb6;</a>
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) ReadRune() (r <a href="/pkg/builtin/#rune">rune</a>, size <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadRune reads and returns the next UTF-8-encoded
Unicode code point from the buffer.
If no bytes are available, the error returned is io.EOF.
If the bytes are an erroneous UTF-8 encoding, it
consumes one byte and returns U+FFFD, 1.
</p>

				
				
				
			
				
				<h3 id="Buffer.ReadString">func (*Buffer) <a href="/src/bytes/buffer.go?s=13708:13772#L425">ReadString</a>
					<a class="permalink" href="#Buffer.ReadString">&#xb6;</a>
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) ReadString(delim <a href="/pkg/builtin/#byte">byte</a>) (line <a href="/pkg/builtin/#string">string</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadString reads until the first occurrence of delim in the input,
returning a string containing the data up to and including the delimiter.
If ReadString encounters an error before finding a delimiter,
it returns the data read before the error and the error itself (often io.EOF).
ReadString returns err != nil if and only if the returned data does not end
in delim.
</p>

				
				
				
			
				
				<h3 id="Buffer.Reset">func (*Buffer) <a href="/src/bytes/buffer.go?s=3634:3658#L88">Reset</a>
					<a class="permalink" href="#Buffer.Reset">&#xb6;</a>
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) Reset()</pre>
				<p>
Reset resets the buffer to be empty,
but it retains the underlying storage for use by future writes.
Reset is the same as Truncate(0).
</p>

				
				
				
			
				
				<h3 id="Buffer.String">func (*Buffer) <a href="/src/bytes/buffer.go?s=2482:2514#L51">String</a>
					<a class="permalink" href="#Buffer.String">&#xb6;</a>
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
String returns the contents of the unread portion of the buffer
as a string. If the Buffer is a nil pointer, it returns &#34;&lt;nil&gt;&#34;.
</p>
<p>
To build strings more efficiently, see the strings.Builder type.
</p>

				
				
				
			
				
				<h3 id="Buffer.Truncate">func (*Buffer) <a href="/src/bytes/buffer.go?s=3287:3319#L73">Truncate</a>
					<a class="permalink" href="#Buffer.Truncate">&#xb6;</a>
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) Truncate(n <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Truncate discards all but the first n unread bytes from the buffer
but continues to use the same allocated storage.
It panics if n is negative or greater than the length of the buffer.
</p>

				
				
				
			
				
				<h3 id="Buffer.UnreadByte">func (*Buffer) <a href="/src/bytes/buffer.go?s=12126:12161#L380">UnreadByte</a>
					<a class="permalink" href="#Buffer.UnreadByte">&#xb6;</a>
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) UnreadByte() <a href="/pkg/builtin/#error">error</a></pre>
				<p>
UnreadByte unreads the last byte returned by the most recent successful
read operation that read at least one byte. If a write has happened since
the last read, if the last read returned an error, or if the read read zero
bytes, UnreadByte returns an error.
</p>

				
				
				
			
				
				<h3 id="Buffer.UnreadRune">func (*Buffer) <a href="/src/bytes/buffer.go?s=11587:11622#L365">UnreadRune</a>
					<a class="permalink" href="#Buffer.UnreadRune">&#xb6;</a>
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) UnreadRune() <a href="/pkg/builtin/#error">error</a></pre>
				<p>
UnreadRune unreads the last rune returned by ReadRune.
If the most recent read or write operation on the buffer was
not a successful ReadRune, UnreadRune returns an error.  (In this regard
it is stricter than UnreadByte, which will unread the last byte
from any read operation.)
</p>

				
				
				
			
				
				<h3 id="Buffer.Write">func (*Buffer) <a href="/src/bytes/buffer.go?s=5775:5826#L160">Write</a>
					<a class="permalink" href="#Buffer.Write">&#xb6;</a>
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) Write(p []<a href="/pkg/builtin/#byte">byte</a>) (n <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Write appends the contents of p to the buffer, growing the buffer as
needed. The return value n is the length of p; err is always nil. If the
buffer becomes too large, Write will panic with ErrTooLarge.
</p>

				
				
				
			
				
				<h3 id="Buffer.WriteByte">func (*Buffer) <a href="/src/bytes/buffer.go?s=8566:8606#L254">WriteByte</a>
					<a class="permalink" href="#Buffer.WriteByte">&#xb6;</a>
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) WriteByte(c <a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>
WriteByte appends the byte c to the buffer, growing the buffer as needed.
The returned error is always nil, but is included to match bufio.Writer&#39;s
WriteByte. If the buffer becomes too large, WriteByte will panic with
ErrTooLarge.
</p>

				
				
				
			
				
				<h3 id="Buffer.WriteRune">func (*Buffer) <a href="/src/bytes/buffer.go?s=9012:9065#L268">WriteRune</a>
					<a class="permalink" href="#Buffer.WriteRune">&#xb6;</a>
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) WriteRune(r <a href="/pkg/builtin/#rune">rune</a>) (n <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
WriteRune appends the UTF-8 encoding of Unicode code point r to the
buffer, returning its length and an error, which is always nil but is
included to match bufio.Writer&#39;s WriteRune. The buffer is grown as needed;
if it becomes too large, WriteRune will panic with ErrTooLarge.
</p>

				
				
				
			
				
				<h3 id="Buffer.WriteString">func (*Buffer) <a href="/src/bytes/buffer.go?s=6183:6240#L172">WriteString</a>
					<a class="permalink" href="#Buffer.WriteString">&#xb6;</a>
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) WriteString(s <a href="/pkg/builtin/#string">string</a>) (n <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
WriteString appends the contents of s to the buffer, growing the buffer as
needed. The return value n is the length of s; err is always nil. If the
buffer becomes too large, WriteString will panic with ErrTooLarge.
</p>

				
				
				
			
				
				<h3 id="Buffer.WriteTo">func (*Buffer) <a href="/src/bytes/buffer.go?s=7824:7882#L227">WriteTo</a>
					<a class="permalink" href="#Buffer.WriteTo">&#xb6;</a>
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) WriteTo(w <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Writer">Writer</a>) (n <a href="/pkg/builtin/#int64">int64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
WriteTo writes data to w until the buffer is drained or an error occurs.
The return value n is the number of bytes written; it always fits into an
int, but it is int64 to match the io.WriterTo interface. Any error
encountered during the write is also returned.
</p>

				
				
				
			
		
			
			
			<h2 id="Reader">type <a href="/src/bytes/reader.go?s=440:570#L7">Reader</a>
				<a class="permalink" href="#Reader">&#xb6;</a>
			</h2>
			<p>
A Reader implements the io.Reader, io.ReaderAt, io.WriterTo, io.Seeker,
io.ByteScanner, and io.RuneScanner interfaces by reading from
a byte slice.
Unlike a Buffer, a Reader is read-only and supports seeking.
</p>

			<pre>type Reader struct {
        <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewReader">func <a href="/src/bytes/reader.go?s=3718:3750#L146">NewReader</a>
					<a class="permalink" href="#NewReader">&#xb6;</a>
				</h3>
				<pre>func NewReader(b []<a href="/pkg/builtin/#byte">byte</a>) *<a href="#Reader">Reader</a></pre>
				<p>
NewReader returns a new Reader reading from b.
</p>

				
				
			

			
				
				<h3 id="Reader.Len">func (*Reader) <a href="/src/bytes/reader.go?s=646:672#L15">Len</a>
					<a class="permalink" href="#Reader.Len">&#xb6;</a>
				</h3>
				<pre>func (r *<a href="#Reader">Reader</a>) Len() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Len returns the number of bytes of the unread portion of the
slice.
</p>

				
				<div id="example_Reader_Len" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bytes&#34;
	&#34;fmt&#34;
)

func main() {
	fmt.Println(bytes.NewReader([]byte(&#34;Hi!&#34;)).Len())
	fmt.Println(bytes.NewReader([]byte(&#34;こんにちは!&#34;)).Len())
}
</textarea></div>
				<div class="output"><pre>3
16
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
				</div>
			</div>
		
	</div>
</div>

				
			
				
				<h3 id="Reader.Read">func (*Reader) <a href="/src/bytes/reader.go?s=1083:1133#L29">Read</a>
					<a class="permalink" href="#Reader.Read">&#xb6;</a>
				</h3>
				<pre>func (r *<a href="#Reader">Reader</a>) Read(b []<a href="/pkg/builtin/#byte">byte</a>) (n <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Read implements the io.Reader interface.
</p>

				
				
				
			
				
				<h3 id="Reader.ReadAt">func (*Reader) <a href="/src/bytes/reader.go?s=1304:1367#L40">ReadAt</a>
					<a class="permalink" href="#Reader.ReadAt">&#xb6;</a>
				</h3>
				<pre>func (r *<a href="#Reader">Reader</a>) ReadAt(b []<a href="/pkg/builtin/#byte">byte</a>, off <a href="/pkg/builtin/#int64">int64</a>) (n <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadAt implements the io.ReaderAt interface.
</p>

				
				
				
			
				
				<h3 id="Reader.ReadByte">func (*Reader) <a href="/src/bytes/reader.go?s=1665:1706#L56">ReadByte</a>
					<a class="permalink" href="#Reader.ReadByte">&#xb6;</a>
				</h3>
				<pre>func (r *<a href="#Reader">Reader</a>) ReadByte() (<a href="/pkg/builtin/#byte">byte</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadByte implements the io.ByteReader interface.
</p>

				
				
				
			
				
				<h3 id="Reader.ReadRune">func (*Reader) <a href="/src/bytes/reader.go?s=2115:2173#L77">ReadRune</a>
					<a class="permalink" href="#Reader.ReadRune">&#xb6;</a>
				</h3>
				<pre>func (r *<a href="#Reader">Reader</a>) ReadRune() (ch <a href="/pkg/builtin/#rune">rune</a>, size <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadRune implements the io.RuneReader interface.
</p>

				
				
				
			
				
				<h3 id="Reader.Reset">func (*Reader) <a href="/src/bytes/reader.go?s=3608:3640#L143">Reset</a>
					<a class="permalink" href="#Reader.Reset">&#xb6;</a>
				</h3>
				<pre>func (r *<a href="#Reader">Reader</a>) Reset(b []<a href="/pkg/builtin/#byte">byte</a>)</pre>
				<p>
Reset resets the Reader to be reading from b.
</p>

				
				
				
			
				
				<h3 id="Reader.Seek">func (*Reader) <a href="/src/bytes/reader.go?s=2744:2806#L103">Seek</a>
					<a class="permalink" href="#Reader.Seek">&#xb6;</a>
				</h3>
				<pre>func (r *<a href="#Reader">Reader</a>) Seek(offset <a href="/pkg/builtin/#int64">int64</a>, whence <a href="/pkg/builtin/#int">int</a>) (<a href="/pkg/builtin/#int64">int64</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Seek implements the io.Seeker interface.
</p>

				
				
				
			
				
				<h3 id="Reader.Size">func (*Reader) <a href="/src/bytes/reader.go?s=981:1010#L26">Size</a>
					<a class="permalink" href="#Reader.Size">&#xb6;</a>
				</h3>
				<pre>func (r *<a href="#Reader">Reader</a>) Size() <a href="/pkg/builtin/#int64">int64</a></pre>
				<p>
Size returns the original length of the underlying byte slice.
Size is the number of bytes available for reading via ReadAt.
The returned value is always the same and is not affected by calls
to any other method.
</p>

				
				
				
			
				
				<h3 id="Reader.UnreadByte">func (*Reader) <a href="/src/bytes/reader.go?s=1898:1933#L67">UnreadByte</a>
					<a class="permalink" href="#Reader.UnreadByte">&#xb6;</a>
				</h3>
				<pre>func (r *<a href="#Reader">Reader</a>) UnreadByte() <a href="/pkg/builtin/#error">error</a></pre>
				<p>
UnreadByte complements ReadByte in implementing the io.ByteScanner interface.
</p>

				
				
				
			
				
				<h3 id="Reader.UnreadRune">func (*Reader) <a href="/src/bytes/reader.go?s=2497:2532#L93">UnreadRune</a>
					<a class="permalink" href="#Reader.UnreadRune">&#xb6;</a>
				</h3>
				<pre>func (r *<a href="#Reader">Reader</a>) UnreadRune() <a href="/pkg/builtin/#error">error</a></pre>
				<p>
UnreadRune complements ReadRune in implementing the io.RuneScanner interface.
</p>

				
				
				
			
				
				<h3 id="Reader.WriteTo">func (*Reader) <a href="/src/bytes/reader.go?s=3220:3278#L124">WriteTo</a>
					<a class="permalink" href="#Reader.WriteTo">&#xb6;</a>
				</h3>
				<pre>func (r *<a href="#Reader">Reader</a>) WriteTo(w <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Writer">Writer</a>) (n <a href="/pkg/builtin/#int64">int64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
WriteTo implements the io.WriterTo interface.
</p>

				
				
				
			
		
	

	
		
			<h2 id="pkg-note-BUG">Bugs</h2>
			<ul style="list-style: none; padding: 0;">
			
			<li><a href="/src/bytes/bytes.go?s=14267:14365#L520" style="float: left;">&#x261e;</a> <p>
The rule Title uses for word boundaries does not handle Unicode punctuation properly.
</p>
</li>
			
			</ul>
		
	







<div id="footer">
Build version go1.10.1.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="/doc/tos.html">Terms of Service</a> |
<a href="http://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
<script type="text/javascript">
(function() {
  var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
  ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
  var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
</html>

